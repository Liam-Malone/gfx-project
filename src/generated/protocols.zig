// WARNING: This file is auto-generated by wl-bindgen,
//          based on the supplied wayland protocols.
//          It is recommended that you do NOT edit this file.
//

pub const std = @import("std");
pub const interface = @import("../wl-interface.zig"); // assume provided by user"
pub const msg = @import("../wl-msg.zig"); // assume provided by user"

// ----------------------- BEGIN PROTOCOL: linux_dmabuf_v1 --------------------------

pub const linux_dmabuf_v1 = struct {
    const log = std.log.scoped(.linux_dmabuf_v1);

    /// factory for creating dmabuf-based wl_buffers
    pub const LinuxDmabufV1 = struct {
        pub const name: [:0]const u8 = "zwp_linux_dmabuf_v1";

        version: u32 = 5,
        id: u32,

        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// unbind the factory
        pub fn destroy(
            self: *const LinuxDmabufV1,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const create_params_params = struct {
            pub const op = 1;
            /// the new temporary
            params_id: ?u32, // id for new zwp_linux_buffer_params_v1 object
        };

        /// create a temporary object for buffer parameters
        pub fn create_params(
            self: *const LinuxDmabufV1,
            writer: anytype,
            params: create_params_params,
        ) !zwp_linux_buffer_params_v1 {
            const res = init: {
                if (params.params_id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, zwp_linux_buffer_params_v1);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(zwp_linux_buffer_params_v1);
                    var write_params: create_params_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_default_feedback_params = struct {
            pub const op = 2;
            id: ?u32, // id for new zwp_linux_dmabuf_feedback_v1 object
        };

        /// get default feedback
        pub fn get_default_feedback(
            self: *const LinuxDmabufV1,
            writer: anytype,
            params: get_default_feedback_params,
        ) !zwp_linux_dmabuf_feedback_v1 {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, zwp_linux_dmabuf_feedback_v1);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(zwp_linux_dmabuf_feedback_v1);
                    var write_params: get_default_feedback_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_surface_feedback_params = struct {
            pub const op = 3;
            id: ?u32, // id for new zwp_linux_dmabuf_feedback_v1 object
            surface: u32,
        };

        /// get feedback for a surface
        pub fn get_surface_feedback(
            self: *const LinuxDmabufV1,
            writer: anytype,
            params: get_surface_feedback_params,
        ) !zwp_linux_dmabuf_feedback_v1 {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, zwp_linux_dmabuf_feedback_v1);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(zwp_linux_dmabuf_feedback_v1);
                    var write_params: get_surface_feedback_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const Event = union(enum) {
            format: Event.Format,
            modifier: Event.Modifier,

            /// supported buffer format
            pub const Format = struct {
                format: u32,
            };

            /// supported buffer format modifier
            pub const Modifier = struct {
                format: u32,
                modifier_hi: u32,
                modifier_lo: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .format = try msg.parse_data(Event.Format, data) },
                    1 => .{ .modifier = try msg.parse_data(Event.Modifier, data) },
                    else => {
                        log.warn("Unknown linux_dmabuf_v1 event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// parameters for creating a dmabuf-based wl_buffer
    pub const LinuxBufferParamsV1 = struct {
        pub const name: [:0]const u8 = "zwp_linux_buffer_params_v1";

        version: u32 = 5,
        id: u32,
        pub const Error = enum(u32) {
            /// the dmabuf_batch object has already been used to create a wl_buffer
            already_used = 0,
            /// plane index out of bounds
            plane_idx = 1,
            /// the plane index was already set
            plane_set = 2,
            /// missing or too many planes to create a buffer
            incomplete = 3,
            /// format not supported
            invalid_format = 4,
            /// invalid width or height
            invalid_dimensions = 5,
            /// offset + stride * height goes out of dmabuf bounds
            out_of_bounds = 6,
            /// invalid wl_buffer resulted from importing dmabufs via the create_immed request on given buffer_params
            invalid_wl_buffer = 7,
        };
        pub const Flags = packed struct(u32) {
            /// contents are y-inverted
            y_invert: bool = false,
            /// content is interlaced
            interlaced: bool = false,
            /// bottom field first
            bottom_first: bool = false,
            __reserved_bit_3: bool = false,
            __reserved_bit_4: bool = false,
            __reserved_bit_5: bool = false,
            __reserved_bit_6: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// delete this object, used or not
        pub fn destroy(
            self: *const LinuxBufferParamsV1,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const add_params = struct {
            pub const op = 1;
            /// dmabuf fd
            fd: std.posix.fd_t,
            /// plane index
            plane_idx: u32,
            /// offset in bytes
            offset: u32,
            /// stride in bytes
            stride: u32,
            /// high 32 bits of layout modifier
            modifier_hi: u32,
            /// low 32 bits of layout modifier
            modifier_lo: u32,
        };

        /// add a dmabuf to the temporary set
        pub fn add(
            self: *const LinuxBufferParamsV1,
            writer: anytype,
            params: add_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const create_params = struct {
            pub const op = 2;
            /// base plane width in pixels
            width: i32,
            /// base plane height in pixels
            height: i32,
            /// DRM_FORMAT code
            format: u32,
            /// see enum flags
            flags: Flags,
        };

        /// create a wl_buffer from the given dmabufs
        pub fn create(
            self: *const LinuxBufferParamsV1,
            writer: anytype,
            params: create_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const create_immed_params = struct {
            pub const op = 3;
            /// id for the newly created wl_buffer
            buffer_id: ?u32, // id for new wl_buffer object
            /// base plane width in pixels
            width: i32,
            /// base plane height in pixels
            height: i32,
            /// DRM_FORMAT code
            format: u32,
            /// see enum flags
            flags: Flags,
        };

        /// immediately create a wl_buffer from the given dmabufs
        pub fn create_immed(
            self: *const LinuxBufferParamsV1,
            writer: anytype,
            params: create_immed_params,
        ) !wl_buffer {
            const res = init: {
                if (params.buffer_id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_buffer);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_buffer);
                    var write_params: create_immed_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const Event = union(enum) {
            created: Event.Created,
            failed: Event.Failed,

            /// buffer creation succeeded
            pub const Created = struct {
                buffer: u32,
            };

            /// buffer creation failed
            pub const Failed = struct {};
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .created = try msg.parse_data(Event.Created, data) },
                    1 => .{ .failed = try msg.parse_data(Event.Failed, data) },
                    else => {
                        log.warn("Unknown linux_buffer_params_v1 event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// dmabuf feedback
    pub const LinuxDmabufFeedbackV1 = struct {
        pub const name: [:0]const u8 = "zwp_linux_dmabuf_feedback_v1";

        version: u32 = 5,
        id: u32,
        pub const TrancheFlags = packed struct(u32) {
            /// direct scan-out tranche
            scanout: bool = false,
            __reserved_bit_1: bool = false,
            __reserved_bit_2: bool = false,
            __reserved_bit_3: bool = false,
            __reserved_bit_4: bool = false,
            __reserved_bit_5: bool = false,
            __reserved_bit_6: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy the feedback object
        pub fn destroy(
            self: *const LinuxDmabufFeedbackV1,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            done: Event.Done,
            format_table: Event.FormatTable,
            main_device: Event.MainDevice,
            tranche_done: Event.TrancheDone,
            tranche_target_device: Event.TrancheTargetDevice,
            tranche_formats: Event.TrancheFormats,
            tranche_flags: Event.TrancheFlags,

            /// all feedback has been sent
            pub const Done = struct {};

            /// format and modifier table
            pub const FormatTable = struct {
                fd: std.posix.fd_t,
                size: u32,
            };

            /// preferred main device
            pub const MainDevice = struct {
                device: []const u8,
            };

            /// a preference tranche has been sent
            pub const TrancheDone = struct {};

            /// target device
            pub const TrancheTargetDevice = struct {
                device: []const u8,
            };

            /// supported buffer format modifier
            pub const TrancheFormats = struct {
                indices: []const u8,
            };

            /// tranche flags
            pub const TrancheFlags = struct {
                flags: LinuxDmabufFeedbackV1.TrancheFlags,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .done = try msg.parse_data(Event.Done, data) },
                    1 => .{ .format_table = try msg.parse_data(Event.FormatTable, data) },
                    2 => .{ .main_device = try msg.parse_data(Event.MainDevice, data) },
                    3 => .{ .tranche_done = try msg.parse_data(Event.TrancheDone, data) },
                    4 => .{ .tranche_target_device = try msg.parse_data(Event.TrancheTargetDevice, data) },
                    5 => .{ .tranche_formats = try msg.parse_data(Event.TrancheFormats, data) },
                    6 => .{ .tranche_flags = try msg.parse_data(Event.TrancheFlags, data) },
                    else => {
                        log.warn("Unknown linux_dmabuf_feedback_v1 event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };
};
const zwp_linux_dmabuf_v1 = linux_dmabuf_v1.LinuxDmabufV1;
const zwp_linux_buffer_params_v1 = linux_dmabuf_v1.LinuxBufferParamsV1;
const zwp_linux_dmabuf_feedback_v1 = linux_dmabuf_v1.LinuxDmabufFeedbackV1;

// ----------------------- END PROTOCOL: linux_dmabuf_v1 --------------------------

// ----------------------- BEGIN PROTOCOL: presentation_time --------------------------

pub const presentation_time = struct {
    const log = std.log.scoped(.presentation_time);

    /// timed presentation related wl_surface requests
    pub const Presentation = struct {
        pub const name: [:0]const u8 = "wp_presentation";

        version: u32 = 2,
        id: u32,

        /// fatal presentation errors
        pub const Error = enum(u32) {
            /// invalid value in tv_nsec
            invalid_timestamp = 0,
            /// invalid flag
            invalid_flag = 1,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// unbind from the presentation interface
        pub fn destroy(
            self: *const Presentation,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const feedback_params = struct {
            pub const op = 1;
            /// target surface
            surface: u32,
            /// new feedback object
            callback: ?u32, // id for new wp_presentation_feedback object
        };

        /// request presentation feedback information
        pub fn feedback(
            self: *const Presentation,
            writer: anytype,
            params: feedback_params,
        ) !wp_presentation_feedback {
            const res = init: {
                if (params.callback) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wp_presentation_feedback);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wp_presentation_feedback);
                    var write_params: feedback_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const Event = union(enum) {
            clock_id: Event.ClockId,

            /// clock ID for timestamps
            pub const ClockId = struct {
                clk_id: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .clock_id = try msg.parse_data(Event.ClockId, data) },
                    else => {
                        log.warn("Unknown presentation event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// presentation time feedback event
    pub const PresentationFeedback = struct {
        pub const name: [:0]const u8 = "wp_presentation_feedback";

        version: u32 = 2,
        id: u32,

        /// bitmask of flags in presented event
        pub const Kind = packed struct(u32) {
            vsync: bool = false,
            hw_clock: bool = false,
            hw_completion: bool = false,
            zero_copy: bool = false,
            __reserved_bit_4: bool = false,
            __reserved_bit_5: bool = false,
            __reserved_bit_6: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        pub const Event = union(enum) {
            sync_output: Event.SyncOutput,
            presented: Event.Presented,
            discarded: Event.Discarded,

            /// presentation synchronized to this output
            pub const SyncOutput = struct {
                output: u32,
            };

            /// the content update was displayed
            pub const Presented = struct {
                tv_sec_hi: u32,
                tv_sec_lo: u32,
                tv_nsec: u32,
                refresh: u32,
                seq_hi: u32,
                seq_lo: u32,
                flags: PresentationFeedback.Kind,
            };

            /// the content update was not displayed
            pub const Discarded = struct {};
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .sync_output = try msg.parse_data(Event.SyncOutput, data) },
                    1 => .{ .presented = try msg.parse_data(Event.Presented, data) },
                    2 => .{ .discarded = try msg.parse_data(Event.Discarded, data) },
                    else => {
                        log.warn("Unknown presentation_feedback event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };
};
const wp_presentation = presentation_time.Presentation;
const wp_presentation_feedback = presentation_time.PresentationFeedback;

// ----------------------- END PROTOCOL: presentation_time --------------------------

// ----------------------- BEGIN PROTOCOL: wayland --------------------------

pub const wayland = struct {
    const log = std.log.scoped(.wayland);

    /// core global object
    pub const Display = struct {
        pub const name: [:0]const u8 = "wl_display";

        version: u32 = 1,
        id: u32,

        /// global error values
        pub const Error = enum(u32) {
            /// server couldn't find object
            invalid_object = 0,
            /// method doesn't exist on the specified interface or malformed request
            invalid_method = 1,
            /// server is out of memory
            no_memory = 2,
            /// implementation error in compositor
            implementation = 3,
        };
        pub const sync_params = struct {
            pub const op = 0;
            /// callback object for the sync request
            callback: ?u32, // id for new wl_callback object
        };

        /// asynchronous roundtrip
        pub fn sync(
            self: *const Display,
            writer: anytype,
            params: sync_params,
        ) !wl_callback {
            const res = init: {
                if (params.callback) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_callback);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_callback);
                    var write_params: sync_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_registry_params = struct {
            pub const op = 1;
            /// global registry object
            registry: ?u32, // id for new wl_registry object
        };

        /// get global registry object
        pub fn get_registry(
            self: *const Display,
            writer: anytype,
            params: get_registry_params,
        ) !wl_registry {
            const res = init: {
                if (params.registry) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_registry);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_registry);
                    var write_params: get_registry_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const Event = union(enum) {
            @"error": Event.Error,
            delete_id: Event.DeleteId,

            /// fatal error event
            pub const Error = struct {
                object_id: u32,
                code: u32,
                message: [:0]const u8,
            };

            /// acknowledge object ID deletion
            pub const DeleteId = struct {
                id: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .@"error" = try msg.parse_data(Event.Error, data) },
                    1 => .{ .delete_id = try msg.parse_data(Event.DeleteId, data) },
                    else => {
                        log.warn("Unknown display event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// global registry object
    pub const Registry = struct {
        pub const name: [:0]const u8 = "wl_registry";

        version: u32 = 1,
        id: u32,

        pub const bind_params = struct {
            pub const op = 0;
            /// unique numeric name of the object
            name: u32,
            /// bounded object
            id_interface: [:0]const u8,
            id_interface_version: u32,
            id: u32,
        };

        /// bind an object to the display
        pub fn bind(
            self: *const Registry,
            writer: anytype,
            params: bind_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            global: Event.Global,
            global_remove: Event.GlobalRemove,

            /// announce global object
            pub const Global = struct {
                name: u32,
                interface: [:0]const u8,
                version: u32,
            };

            /// announce removal of global object
            pub const GlobalRemove = struct {
                name: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .global = try msg.parse_data(Event.Global, data) },
                    1 => .{ .global_remove = try msg.parse_data(Event.GlobalRemove, data) },
                    else => {
                        log.warn("Unknown registry event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// callback object
    pub const Callback = struct {
        pub const name: [:0]const u8 = "wl_callback";

        version: u32 = 1,
        id: u32,
        pub const Event = union(enum) {
            done: Event.Done,

            /// done event
            pub const Done = struct {
                callback_data: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .done = try msg.parse_data(Event.Done, data) },
                    else => {
                        log.warn("Unknown callback event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// the compositor singleton
    pub const Compositor = struct {
        pub const name: [:0]const u8 = "wl_compositor";

        version: u32 = 6,
        id: u32,

        pub const create_surface_params = struct {
            pub const op = 0;
            /// the new surface
            id: ?u32, // id for new wl_surface object
        };

        /// create new surface
        pub fn create_surface(
            self: *const Compositor,
            writer: anytype,
            params: create_surface_params,
        ) !wl_surface {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_surface);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_surface);
                    var write_params: create_surface_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const create_region_params = struct {
            pub const op = 1;
            /// the new region
            id: ?u32, // id for new wl_region object
        };

        /// create new region
        pub fn create_region(
            self: *const Compositor,
            writer: anytype,
            params: create_region_params,
        ) !wl_region {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_region);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_region);
                    var write_params: create_region_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }
    };

    /// a shared memory pool
    pub const ShmPool = struct {
        pub const name: [:0]const u8 = "wl_shm_pool";

        version: u32 = 2,
        id: u32,

        pub const create_buffer_params = struct {
            pub const op = 0;
            /// buffer to create
            id: ?u32, // id for new wl_buffer object
            /// buffer byte offset within the pool
            offset: i32,
            /// buffer width, in pixels
            width: i32,
            /// buffer height, in pixels
            height: i32,
            /// number of bytes from the beginning of one row to the beginning of the next row
            stride: i32,
            /// buffer pixel format
            format: Shm.Format,
        };

        /// create a buffer from the pool
        pub fn create_buffer(
            self: *const ShmPool,
            writer: anytype,
            params: create_buffer_params,
        ) !wl_buffer {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_buffer);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_buffer);
                    var write_params: create_buffer_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const destroy_params = struct {
            pub const op = 1;
        };

        /// destroy the pool
        pub fn destroy(
            self: *const ShmPool,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const resize_params = struct {
            pub const op = 2;
            /// new size of the pool, in bytes
            size: i32,
        };

        /// change the size of the pool mapping
        pub fn resize(
            self: *const ShmPool,
            writer: anytype,
            params: resize_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }
    };

    /// shared memory support
    pub const Shm = struct {
        pub const name: [:0]const u8 = "wl_shm";

        version: u32 = 2,
        id: u32,

        /// wl_shm error values
        pub const Error = enum(u32) {
            /// buffer format is not known
            invalid_format = 0,
            /// invalid size or stride during pool or buffer creation
            invalid_stride = 1,
            /// mmapping the file descriptor failed
            invalid_fd = 2,
        };
        /// pixel formats
        pub const Format = enum(u32) {
            /// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
            argb8888 = 0,
            /// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
            xrgb8888 = 1,
            /// 8-bit color index format, [7:0] C
            c8 = 0x20203843,
            /// 8-bit RGB format, [7:0] R:G:B 3:3:2
            rgb332 = 0x38424752,
            /// 8-bit BGR format, [7:0] B:G:R 2:3:3
            bgr233 = 0x38524742,
            /// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
            xrgb4444 = 0x32315258,
            /// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
            xbgr4444 = 0x32314258,
            /// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
            rgbx4444 = 0x32315852,
            /// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
            bgrx4444 = 0x32315842,
            /// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
            argb4444 = 0x32315241,
            /// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
            abgr4444 = 0x32314241,
            /// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
            rgba4444 = 0x32314152,
            /// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
            bgra4444 = 0x32314142,
            /// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
            xrgb1555 = 0x35315258,
            /// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
            xbgr1555 = 0x35314258,
            /// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
            rgbx5551 = 0x35315852,
            /// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
            bgrx5551 = 0x35315842,
            /// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
            argb1555 = 0x35315241,
            /// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
            abgr1555 = 0x35314241,
            /// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
            rgba5551 = 0x35314152,
            /// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
            bgra5551 = 0x35314142,
            /// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
            rgb565 = 0x36314752,
            /// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
            bgr565 = 0x36314742,
            /// 24-bit RGB format, [23:0] R:G:B little endian
            rgb888 = 0x34324752,
            /// 24-bit BGR format, [23:0] B:G:R little endian
            bgr888 = 0x34324742,
            /// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
            xbgr8888 = 0x34324258,
            /// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
            rgbx8888 = 0x34325852,
            /// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
            bgrx8888 = 0x34325842,
            /// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
            abgr8888 = 0x34324241,
            /// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
            rgba8888 = 0x34324152,
            /// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
            bgra8888 = 0x34324142,
            /// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
            xrgb2101010 = 0x30335258,
            /// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
            xbgr2101010 = 0x30334258,
            /// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
            rgbx1010102 = 0x30335852,
            /// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
            bgrx1010102 = 0x30335842,
            /// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
            argb2101010 = 0x30335241,
            /// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
            abgr2101010 = 0x30334241,
            /// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
            rgba1010102 = 0x30334152,
            /// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
            bgra1010102 = 0x30334142,
            /// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
            yuyv = 0x56595559,
            /// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
            yvyu = 0x55595659,
            /// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
            uyvy = 0x59565955,
            /// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
            vyuy = 0x59555956,
            /// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
            ayuv = 0x56555941,
            /// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
            nv12 = 0x3231564e,
            /// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
            nv21 = 0x3132564e,
            /// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
            nv16 = 0x3631564e,
            /// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
            nv61 = 0x3136564e,
            /// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
            yuv410 = 0x39565559,
            /// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
            yvu410 = 0x39555659,
            /// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
            yuv411 = 0x31315559,
            /// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
            yvu411 = 0x31315659,
            /// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
            yuv420 = 0x32315559,
            /// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
            yvu420 = 0x32315659,
            /// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
            yuv422 = 0x36315559,
            /// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
            yvu422 = 0x36315659,
            /// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
            yuv444 = 0x34325559,
            /// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
            yvu444 = 0x34325659,
            /// [7:0] R
            r8 = 0x20203852,
            /// [15:0] R little endian
            r16 = 0x20363152,
            /// [15:0] R:G 8:8 little endian
            rg88 = 0x38384752,
            /// [15:0] G:R 8:8 little endian
            gr88 = 0x38385247,
            /// [31:0] R:G 16:16 little endian
            rg1616 = 0x32334752,
            /// [31:0] G:R 16:16 little endian
            gr1616 = 0x32335247,
            /// [63:0] x:R:G:B 16:16:16:16 little endian
            xrgb16161616f = 0x48345258,
            /// [63:0] x:B:G:R 16:16:16:16 little endian
            xbgr16161616f = 0x48344258,
            /// [63:0] A:R:G:B 16:16:16:16 little endian
            argb16161616f = 0x48345241,
            /// [63:0] A:B:G:R 16:16:16:16 little endian
            abgr16161616f = 0x48344241,
            /// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
            xyuv8888 = 0x56555958,
            /// [23:0] Cr:Cb:Y 8:8:8 little endian
            vuy888 = 0x34325556,
            /// Y followed by U then V, 10:10:10. Non-linear modifier only
            vuy101010 = 0x30335556,
            /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
            y210 = 0x30313259,
            /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
            y212 = 0x32313259,
            /// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
            y216 = 0x36313259,
            /// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
            y410 = 0x30313459,
            /// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
            y412 = 0x32313459,
            /// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
            y416 = 0x36313459,
            /// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
            xvyu2101010 = 0x30335658,
            /// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
            xvyu12_16161616 = 0x36335658,
            /// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
            xvyu16161616 = 0x38345658,
            /// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
            y0l0 = 0x304c3059,
            /// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
            x0l0 = 0x304c3058,
            /// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
            y0l2 = 0x324c3059,
            /// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
            x0l2 = 0x324c3058,
            yuv420_8bit = 0x38305559,
            yuv420_10bit = 0x30315559,
            xrgb8888_a8 = 0x38415258,
            xbgr8888_a8 = 0x38414258,
            rgbx8888_a8 = 0x38415852,
            bgrx8888_a8 = 0x38415842,
            rgb888_a8 = 0x38413852,
            bgr888_a8 = 0x38413842,
            rgb565_a8 = 0x38413552,
            bgr565_a8 = 0x38413542,
            /// non-subsampled Cr:Cb plane
            nv24 = 0x3432564e,
            /// non-subsampled Cb:Cr plane
            nv42 = 0x3234564e,
            /// 2x1 subsampled Cr:Cb plane, 10 bit per channel
            p210 = 0x30313250,
            /// 2x2 subsampled Cr:Cb plane 10 bits per channel
            p010 = 0x30313050,
            /// 2x2 subsampled Cr:Cb plane 12 bits per channel
            p012 = 0x32313050,
            /// 2x2 subsampled Cr:Cb plane 16 bits per channel
            p016 = 0x36313050,
            /// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
            axbxgxrx106106106106 = 0x30314241,
            /// 2x2 subsampled Cr:Cb plane
            nv15 = 0x3531564e,
            q410 = 0x30313451,
            q401 = 0x31303451,
            /// [63:0] x:R:G:B 16:16:16:16 little endian
            xrgb16161616 = 0x38345258,
            /// [63:0] x:B:G:R 16:16:16:16 little endian
            xbgr16161616 = 0x38344258,
            /// [63:0] A:R:G:B 16:16:16:16 little endian
            argb16161616 = 0x38345241,
            /// [63:0] A:B:G:R 16:16:16:16 little endian
            abgr16161616 = 0x38344241,
            /// [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
            c1 = 0x20203143,
            /// [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
            c2 = 0x20203243,
            /// [7:0] C0:C1 4:4 two pixels/byte
            c4 = 0x20203443,
            /// [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
            d1 = 0x20203144,
            /// [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
            d2 = 0x20203244,
            /// [7:0] D0:D1 4:4 two pixels/byte
            d4 = 0x20203444,
            /// [7:0] D
            d8 = 0x20203844,
            /// [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
            r1 = 0x20203152,
            /// [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
            r2 = 0x20203252,
            /// [7:0] R0:R1 4:4 two pixels/byte
            r4 = 0x20203452,
            /// [15:0] x:R 6:10 little endian
            r10 = 0x20303152,
            /// [15:0] x:R 4:12 little endian
            r12 = 0x20323152,
            /// [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
            avuy8888 = 0x59555641,
            /// [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
            xvuy8888 = 0x59555658,
            /// 2x2 subsampled Cr:Cb plane 10 bits per channel packed
            p030 = 0x30333050,
        };
        pub const create_pool_params = struct {
            pub const op = 0;
            /// pool to create
            id: ?u32, // id for new wl_shm_pool object
            /// file descriptor for the pool
            fd: std.posix.fd_t,
            /// pool size, in bytes
            size: i32,
        };

        /// create a shm pool
        pub fn create_pool(
            self: *const Shm,
            writer: anytype,
            params: create_pool_params,
        ) !wl_shm_pool {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_shm_pool);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_shm_pool);
                    var write_params: create_pool_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const release_params = struct {
            pub const op = 1;
        };

        /// release the shm object
        pub fn release(
            self: *const Shm,
            writer: anytype,
            params: release_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            format: Event.Format,

            /// pixel format description
            pub const Format = struct {
                format: Shm.Format,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .format = try msg.parse_data(Event.Format, data) },
                    else => {
                        log.warn("Unknown shm event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// content for a wl_surface
    pub const Buffer = struct {
        pub const name: [:0]const u8 = "wl_buffer";

        version: u32 = 1,
        id: u32,

        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy a buffer
        pub fn destroy(
            self: *const Buffer,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            release: Event.Release,

            /// compositor releases buffer
            pub const Release = struct {};
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .release = try msg.parse_data(Event.Release, data) },
                    else => {
                        log.warn("Unknown buffer event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// offer to transfer data
    pub const DataOffer = struct {
        pub const name: [:0]const u8 = "wl_data_offer";

        version: u32 = 3,
        id: u32,
        pub const Error = enum(u32) {
            /// finish request was called untimely
            invalid_finish = 0,
            /// action mask contains invalid values
            invalid_action_mask = 1,
            /// action argument has an invalid value
            invalid_action = 2,
            /// offer doesn't accept this request
            invalid_offer = 3,
        };
        pub const accept_params = struct {
            pub const op = 0;
            /// serial number of the accept request
            serial: u32,
            /// mime type accepted by the client
            mime_type: [:0]const u8,
        };

        /// accept one of the offered mime types
        pub fn accept(
            self: *const DataOffer,
            writer: anytype,
            params: accept_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const receive_params = struct {
            pub const op = 1;
            /// mime type desired by receiver
            mime_type: [:0]const u8,
            /// file descriptor for data transfer
            fd: std.posix.fd_t,
        };

        /// request that the data is transferred
        pub fn receive(
            self: *const DataOffer,
            writer: anytype,
            params: receive_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const destroy_params = struct {
            pub const op = 2;
        };

        /// destroy data offer
        pub fn destroy(
            self: *const DataOffer,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const finish_params = struct {
            pub const op = 3;
        };

        /// the offer will no longer be used
        pub fn finish(
            self: *const DataOffer,
            writer: anytype,
            params: finish_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_actions_params = struct {
            pub const op = 4;
            /// actions supported by the destination client
            dnd_actions: DataDeviceManager.DndAction,
            /// action preferred by the destination client
            preferred_action: DataDeviceManager.DndAction,
        };

        /// set the available/preferred drag-and-drop actions
        pub fn set_actions(
            self: *const DataOffer,
            writer: anytype,
            params: set_actions_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            offer: Event.Offer,
            source_actions: Event.SourceActions,
            action: Event.Action,

            /// advertise offered mime type
            pub const Offer = struct {
                mime_type: [:0]const u8,
            };

            /// notify the source-side available actions
            pub const SourceActions = struct {
                source_actions: DataDeviceManager.DndAction,
            };

            /// notify the selected action
            pub const Action = struct {
                dnd_action: DataDeviceManager.DndAction,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .offer = try msg.parse_data(Event.Offer, data) },
                    1 => .{ .source_actions = try msg.parse_data(Event.SourceActions, data) },
                    2 => .{ .action = try msg.parse_data(Event.Action, data) },
                    else => {
                        log.warn("Unknown data_offer event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// offer to transfer data
    pub const DataSource = struct {
        pub const name: [:0]const u8 = "wl_data_source";

        version: u32 = 3,
        id: u32,
        pub const Error = enum(u32) {
            /// action mask contains invalid values
            invalid_action_mask = 0,
            /// source doesn't accept this request
            invalid_source = 1,
        };
        pub const offer_params = struct {
            pub const op = 0;
            /// mime type offered by the data source
            mime_type: [:0]const u8,
        };

        /// add an offered mime type
        pub fn offer(
            self: *const DataSource,
            writer: anytype,
            params: offer_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const destroy_params = struct {
            pub const op = 1;
        };

        /// destroy the data source
        pub fn destroy(
            self: *const DataSource,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const set_actions_params = struct {
            pub const op = 2;
            /// actions supported by the data source
            dnd_actions: DataDeviceManager.DndAction,
        };

        /// set the available drag-and-drop actions
        pub fn set_actions(
            self: *const DataSource,
            writer: anytype,
            params: set_actions_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            target: Event.Target,
            send: Event.Send,
            cancelled: Event.Cancelled,
            dnd_drop_performed: Event.DndDropPerformed,
            dnd_finished: Event.DndFinished,
            action: Event.Action,

            /// a target accepts an offered mime type
            pub const Target = struct {
                mime_type: [:0]const u8,
            };

            /// send the data
            pub const Send = struct {
                mime_type: [:0]const u8,
                fd: std.posix.fd_t,
            };

            /// selection was cancelled
            pub const Cancelled = struct {};

            /// the drag-and-drop operation physically finished
            pub const DndDropPerformed = struct {};

            /// the drag-and-drop operation concluded
            pub const DndFinished = struct {};

            /// notify the selected action
            pub const Action = struct {
                dnd_action: DataDeviceManager.DndAction,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .target = try msg.parse_data(Event.Target, data) },
                    1 => .{ .send = try msg.parse_data(Event.Send, data) },
                    2 => .{ .cancelled = try msg.parse_data(Event.Cancelled, data) },
                    3 => .{ .dnd_drop_performed = try msg.parse_data(Event.DndDropPerformed, data) },
                    4 => .{ .dnd_finished = try msg.parse_data(Event.DndFinished, data) },
                    5 => .{ .action = try msg.parse_data(Event.Action, data) },
                    else => {
                        log.warn("Unknown data_source event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// data transfer device
    pub const DataDevice = struct {
        pub const name: [:0]const u8 = "wl_data_device";

        version: u32 = 3,
        id: u32,
        pub const Error = enum(u32) {
            /// given wl_surface has another role
            role = 0,
            /// source has already been used
            used_source = 1,
        };
        pub const start_drag_params = struct {
            pub const op = 0;
            /// data source for the eventual transfer
            source: u32,
            /// surface where the drag originates
            origin: u32,
            /// drag-and-drop icon surface
            icon: u32,
            /// serial number of the implicit grab on the origin
            serial: u32,
        };

        /// start drag-and-drop operation
        pub fn start_drag(
            self: *const DataDevice,
            writer: anytype,
            params: start_drag_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_selection_params = struct {
            pub const op = 1;
            /// data source for the selection
            source: u32,
            /// serial number of the event that triggered this request
            serial: u32,
        };

        /// copy data to the selection
        pub fn set_selection(
            self: *const DataDevice,
            writer: anytype,
            params: set_selection_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const release_params = struct {
            pub const op = 2;
        };

        /// destroy data device
        pub fn release(
            self: *const DataDevice,
            writer: anytype,
            params: release_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            data_offer: Event.DataOffer,
            enter: Event.Enter,
            leave: Event.Leave,
            motion: Event.Motion,
            drop: Event.Drop,
            selection: Event.Selection,

            /// introduce a new wl_data_offer
            pub const DataOffer = struct {
                id: u32,
            };

            /// initiate drag-and-drop session
            pub const Enter = struct {
                serial: u32,
                surface: u32,
                x: f32,
                y: f32,
                id: u32,
            };

            /// end drag-and-drop session
            pub const Leave = struct {};

            /// drag-and-drop session motion
            pub const Motion = struct {
                time: u32,
                x: f32,
                y: f32,
            };

            /// end drag-and-drop session successfully
            pub const Drop = struct {};

            /// advertise new selection
            pub const Selection = struct {
                id: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .data_offer = try msg.parse_data(Event.DataOffer, data) },
                    1 => .{ .enter = try msg.parse_data(Event.Enter, data) },
                    2 => .{ .leave = try msg.parse_data(Event.Leave, data) },
                    3 => .{ .motion = try msg.parse_data(Event.Motion, data) },
                    4 => .{ .drop = try msg.parse_data(Event.Drop, data) },
                    5 => .{ .selection = try msg.parse_data(Event.Selection, data) },
                    else => {
                        log.warn("Unknown data_device event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// data transfer interface
    pub const DataDeviceManager = struct {
        pub const name: [:0]const u8 = "wl_data_device_manager";

        version: u32 = 3,
        id: u32,

        /// drag and drop actions
        pub const DndAction = packed struct(u32) {
            /// no action
            none: bool = false,
            /// copy action
            copy: bool = false,
            /// move action
            move: bool = false,
            /// ask action
            ask: bool = false,
            __reserved_bit_4: bool = false,
            __reserved_bit_5: bool = false,
            __reserved_bit_6: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        pub const create_data_source_params = struct {
            pub const op = 0;
            /// data source to create
            id: ?u32, // id for new wl_data_source object
        };

        /// create a new data source
        pub fn create_data_source(
            self: *const DataDeviceManager,
            writer: anytype,
            params: create_data_source_params,
        ) !wl_data_source {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_data_source);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_data_source);
                    var write_params: create_data_source_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_data_device_params = struct {
            pub const op = 1;
            /// data device to create
            id: ?u32, // id for new wl_data_device object
            /// seat associated with the data device
            seat: u32,
        };

        /// create a new data device
        pub fn get_data_device(
            self: *const DataDeviceManager,
            writer: anytype,
            params: get_data_device_params,
        ) !wl_data_device {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_data_device);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_data_device);
                    var write_params: get_data_device_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }
    };

    /// create desktop-style surfaces
    pub const Shell = struct {
        pub const name: [:0]const u8 = "wl_shell";

        version: u32 = 1,
        id: u32,
        pub const Error = enum(u32) {
            /// given wl_surface has another role
            role = 0,
        };
        pub const get_shell_surface_params = struct {
            pub const op = 0;
            /// shell surface to create
            id: ?u32, // id for new wl_shell_surface object
            /// surface to be given the shell surface role
            surface: u32,
        };

        /// create a shell surface from a surface
        pub fn get_shell_surface(
            self: *const Shell,
            writer: anytype,
            params: get_shell_surface_params,
        ) !wl_shell_surface {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_shell_surface);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_shell_surface);
                    var write_params: get_shell_surface_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }
    };

    /// desktop-style metadata interface
    pub const ShellSurface = struct {
        pub const name: [:0]const u8 = "wl_shell_surface";

        version: u32 = 1,
        id: u32,

        /// edge values for resizing
        pub const Resize = packed struct(u32) {
            /// no edge
            none: bool = false,
            /// top edge
            top: bool = false,
            /// bottom edge
            bottom: bool = false,
            /// left edge
            left: bool = false,
            /// top and left edges
            top_left: bool = false,
            /// bottom and left edges
            bottom_left: bool = false,
            /// right edge
            right: bool = false,
            /// top and right edges
            top_right: bool = false,
            /// bottom and right edges
            bottom_right: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        /// details of transient behaviour
        pub const Transient = packed struct(u32) {
            /// do not set keyboard focus
            inactive: bool = false,
            __reserved_bit_1: bool = false,
            __reserved_bit_2: bool = false,
            __reserved_bit_3: bool = false,
            __reserved_bit_4: bool = false,
            __reserved_bit_5: bool = false,
            __reserved_bit_6: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        /// different method to set the surface fullscreen
        pub const FullscreenMethod = enum(u32) {
            /// no preference, apply default policy
            default = 0,
            /// scale, preserve the surface's aspect ratio and center on output
            scale = 1,
            /// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
            driver = 2,
            /// no upscaling, center on output and add black borders to compensate size mismatch
            fill = 3,
        };
        pub const pong_params = struct {
            pub const op = 0;
            /// serial number of the ping event
            serial: u32,
        };

        /// respond to a ping event
        pub fn pong(
            self: *const ShellSurface,
            writer: anytype,
            params: pong_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const move_params = struct {
            pub const op = 1;
            /// seat whose pointer is used
            seat: u32,
            /// serial number of the implicit grab on the pointer
            serial: u32,
        };

        /// start an interactive move
        pub fn move(
            self: *const ShellSurface,
            writer: anytype,
            params: move_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const resize_params = struct {
            pub const op = 2;
            /// seat whose pointer is used
            seat: u32,
            /// serial number of the implicit grab on the pointer
            serial: u32,
            /// which edge or corner is being dragged
            edges: Resize,
        };

        /// start an interactive resize
        pub fn resize(
            self: *const ShellSurface,
            writer: anytype,
            params: resize_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_toplevel_params = struct {
            pub const op = 3;
        };

        /// make the surface a toplevel surface
        pub fn set_toplevel(
            self: *const ShellSurface,
            writer: anytype,
            params: set_toplevel_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_transient_params = struct {
            pub const op = 4;
            /// parent surface
            parent: u32,
            /// surface-local x coordinate
            x: i32,
            /// surface-local y coordinate
            y: i32,
            /// transient surface behavior
            flags: Transient,
        };

        /// make the surface a transient surface
        pub fn set_transient(
            self: *const ShellSurface,
            writer: anytype,
            params: set_transient_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_fullscreen_params = struct {
            pub const op = 5;
            /// method for resolving size conflict
            method: FullscreenMethod,
            /// framerate in mHz
            framerate: u32,
            /// output on which the surface is to be fullscreen
            output: u32,
        };

        /// make the surface a fullscreen surface
        pub fn set_fullscreen(
            self: *const ShellSurface,
            writer: anytype,
            params: set_fullscreen_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_popup_params = struct {
            pub const op = 6;
            /// seat whose pointer is used
            seat: u32,
            /// serial number of the implicit grab on the pointer
            serial: u32,
            /// parent surface
            parent: u32,
            /// surface-local x coordinate
            x: i32,
            /// surface-local y coordinate
            y: i32,
            /// transient surface behavior
            flags: Transient,
        };

        /// make the surface a popup surface
        pub fn set_popup(
            self: *const ShellSurface,
            writer: anytype,
            params: set_popup_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_maximized_params = struct {
            pub const op = 7;
            /// output on which the surface is to be maximized
            output: u32,
        };

        /// make the surface a maximized surface
        pub fn set_maximized(
            self: *const ShellSurface,
            writer: anytype,
            params: set_maximized_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_title_params = struct {
            pub const op = 8;
            /// surface title
            title: [:0]const u8,
        };

        /// set surface title
        pub fn set_title(
            self: *const ShellSurface,
            writer: anytype,
            params: set_title_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_class_params = struct {
            pub const op = 9;
            /// surface class
            class_: [:0]const u8,
        };

        /// set surface class
        pub fn set_class(
            self: *const ShellSurface,
            writer: anytype,
            params: set_class_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            ping: Event.Ping,
            configure: Event.Configure,
            popup_done: Event.PopupDone,

            /// ping client
            pub const Ping = struct {
                serial: u32,
            };

            /// suggest resize
            pub const Configure = struct {
                edges: ShellSurface.Resize,
                width: i32,
                height: i32,
            };

            /// popup interaction is done
            pub const PopupDone = struct {};
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .ping = try msg.parse_data(Event.Ping, data) },
                    1 => .{ .configure = try msg.parse_data(Event.Configure, data) },
                    2 => .{ .popup_done = try msg.parse_data(Event.PopupDone, data) },
                    else => {
                        log.warn("Unknown shell_surface event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// an onscreen surface
    pub const Surface = struct {
        pub const name: [:0]const u8 = "wl_surface";

        version: u32 = 6,
        id: u32,

        /// wl_surface error values
        pub const Error = enum(u32) {
            /// buffer scale value is invalid
            invalid_scale = 0,
            /// buffer transform value is invalid
            invalid_transform = 1,
            /// buffer size is invalid
            invalid_size = 2,
            /// buffer offset is invalid
            invalid_offset = 3,
            /// surface was destroyed before its role object
            defunct_role_object = 4,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// delete surface
        pub fn destroy(
            self: *const Surface,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const attach_params = struct {
            pub const op = 1;
            /// buffer of surface contents
            buffer: u32,
            /// surface-local x coordinate
            x: i32,
            /// surface-local y coordinate
            y: i32,
        };

        /// set the surface contents
        pub fn attach(
            self: *const Surface,
            writer: anytype,
            params: attach_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const damage_params = struct {
            pub const op = 2;
            /// surface-local x coordinate
            x: i32,
            /// surface-local y coordinate
            y: i32,
            /// width of damage rectangle
            width: i32,
            /// height of damage rectangle
            height: i32,
        };

        /// mark part of the surface damaged
        pub fn damage(
            self: *const Surface,
            writer: anytype,
            params: damage_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const frame_params = struct {
            pub const op = 3;
            /// callback object for the frame request
            callback: ?u32, // id for new wl_callback object
        };

        /// request a frame throttling hint
        pub fn frame(
            self: *const Surface,
            writer: anytype,
            params: frame_params,
        ) !wl_callback {
            const res = init: {
                if (params.callback) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_callback);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_callback);
                    var write_params: frame_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const set_opaque_region_params = struct {
            pub const op = 4;
            /// opaque region of the surface
            region: u32,
        };

        /// set opaque region
        pub fn set_opaque_region(
            self: *const Surface,
            writer: anytype,
            params: set_opaque_region_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_input_region_params = struct {
            pub const op = 5;
            /// input region of the surface
            region: u32,
        };

        /// set input region
        pub fn set_input_region(
            self: *const Surface,
            writer: anytype,
            params: set_input_region_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const commit_params = struct {
            pub const op = 6;
        };

        /// commit pending surface state
        pub fn commit(
            self: *const Surface,
            writer: anytype,
            params: commit_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_buffer_transform_params = struct {
            pub const op = 7;
            /// transform for interpreting buffer contents
            transform: Output.Transform,
        };

        /// sets the buffer transformation
        pub fn set_buffer_transform(
            self: *const Surface,
            writer: anytype,
            params: set_buffer_transform_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_buffer_scale_params = struct {
            pub const op = 8;
            /// scale for interpreting buffer contents
            scale: i32,
        };

        /// sets the buffer scaling factor
        pub fn set_buffer_scale(
            self: *const Surface,
            writer: anytype,
            params: set_buffer_scale_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const damage_buffer_params = struct {
            pub const op = 9;
            /// buffer-local x coordinate
            x: i32,
            /// buffer-local y coordinate
            y: i32,
            /// width of damage rectangle
            width: i32,
            /// height of damage rectangle
            height: i32,
        };

        /// mark part of the surface damaged using buffer coordinates
        pub fn damage_buffer(
            self: *const Surface,
            writer: anytype,
            params: damage_buffer_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const offset_params = struct {
            pub const op = 10;
            /// surface-local x coordinate
            x: i32,
            /// surface-local y coordinate
            y: i32,
        };

        /// set the surface contents offset
        pub fn offset(
            self: *const Surface,
            writer: anytype,
            params: offset_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            enter: Event.Enter,
            leave: Event.Leave,
            preferred_buffer_scale: Event.PreferredBufferScale,
            preferred_buffer_transform: Event.PreferredBufferTransform,

            /// surface enters an output
            pub const Enter = struct {
                output: u32,
            };

            /// surface leaves an output
            pub const Leave = struct {
                output: u32,
            };

            /// preferred buffer scale for the surface
            pub const PreferredBufferScale = struct {
                factor: i32,
            };

            /// preferred buffer transform for the surface
            pub const PreferredBufferTransform = struct {
                transform: Output.Transform,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .enter = try msg.parse_data(Event.Enter, data) },
                    1 => .{ .leave = try msg.parse_data(Event.Leave, data) },
                    2 => .{ .preferred_buffer_scale = try msg.parse_data(Event.PreferredBufferScale, data) },
                    3 => .{ .preferred_buffer_transform = try msg.parse_data(Event.PreferredBufferTransform, data) },
                    else => {
                        log.warn("Unknown surface event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// group of input devices
    pub const Seat = struct {
        pub const name: [:0]const u8 = "wl_seat";

        version: u32 = 10,
        id: u32,

        /// seat capability bitmask
        pub const Capability = packed struct(u32) {
            /// the seat has pointer devices
            pointer: bool = false,
            /// the seat has one or more keyboards
            keyboard: bool = false,
            /// the seat has touch devices
            touch: bool = false,
            __reserved_bit_3: bool = false,
            __reserved_bit_4: bool = false,
            __reserved_bit_5: bool = false,
            __reserved_bit_6: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        /// wl_seat error values
        pub const Error = enum(u32) {
            /// get_pointer, get_keyboard or get_touch called on seat without the matching capability
            missing_capability = 0,
        };
        pub const get_pointer_params = struct {
            pub const op = 0;
            /// seat pointer
            id: ?u32, // id for new wl_pointer object
        };

        /// return pointer object
        pub fn get_pointer(
            self: *const Seat,
            writer: anytype,
            params: get_pointer_params,
        ) !wl_pointer {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_pointer);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_pointer);
                    var write_params: get_pointer_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_keyboard_params = struct {
            pub const op = 1;
            /// seat keyboard
            id: ?u32, // id for new wl_keyboard object
        };

        /// return keyboard object
        pub fn get_keyboard(
            self: *const Seat,
            writer: anytype,
            params: get_keyboard_params,
        ) !wl_keyboard {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_keyboard);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_keyboard);
                    var write_params: get_keyboard_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_touch_params = struct {
            pub const op = 2;
            /// seat touch interface
            id: ?u32, // id for new wl_touch object
        };

        /// return touch object
        pub fn get_touch(
            self: *const Seat,
            writer: anytype,
            params: get_touch_params,
        ) !wl_touch {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_touch);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_touch);
                    var write_params: get_touch_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const release_params = struct {
            pub const op = 3;
        };

        /// release the seat object
        pub fn release(
            self: *const Seat,
            writer: anytype,
            params: release_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            capabilities: Event.Capabilities,
            name: Event.Name,

            /// seat capabilities changed
            pub const Capabilities = struct {
                capabilities: Seat.Capability,
            };

            /// unique identifier for this seat
            pub const Name = struct {
                name: [:0]const u8,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .capabilities = try msg.parse_data(Event.Capabilities, data) },
                    1 => .{ .name = try msg.parse_data(Event.Name, data) },
                    else => {
                        log.warn("Unknown seat event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// pointer input device
    pub const Pointer = struct {
        pub const name: [:0]const u8 = "wl_pointer";

        version: u32 = 10,
        id: u32,
        pub const Error = enum(u32) {
            /// given wl_surface has another role
            role = 0,
        };
        /// physical button state
        pub const ButtonState = enum(u32) {
            /// the button is not pressed
            released = 0,
            /// the button is pressed
            pressed = 1,
        };
        /// axis types
        pub const Axis = enum(u32) {
            /// vertical axis
            vertical_scroll = 0,
            /// horizontal axis
            horizontal_scroll = 1,
        };
        /// axis source types
        pub const AxisSource = enum(u32) {
            /// a physical wheel rotation
            wheel = 0,
            /// finger on a touch surface
            finger = 1,
            /// continuous coordinate space
            continuous = 2,
            /// a physical wheel tilt
            wheel_tilt = 3,
        };
        /// axis relative direction
        pub const AxisRelativeDirection = enum(u32) {
            /// physical motion matches axis direction
            identical = 0,
            /// physical motion is the inverse of the axis direction
            inverted = 1,
        };
        pub const set_cursor_params = struct {
            pub const op = 0;
            /// serial number of the enter event
            serial: u32,
            /// pointer surface
            surface: u32,
            /// surface-local x coordinate
            hotspot_x: i32,
            /// surface-local y coordinate
            hotspot_y: i32,
        };

        /// set the pointer surface
        pub fn set_cursor(
            self: *const Pointer,
            writer: anytype,
            params: set_cursor_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const release_params = struct {
            pub const op = 1;
        };

        /// release the pointer object
        pub fn release(
            self: *const Pointer,
            writer: anytype,
            params: release_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            enter: Event.Enter,
            leave: Event.Leave,
            motion: Event.Motion,
            button: Event.Button,
            axis: Event.Axis,
            frame: Event.Frame,
            axis_source: Event.AxisSource,
            axis_stop: Event.AxisStop,
            axis_discrete: Event.AxisDiscrete,
            axis_value120: Event.AxisValue120,
            axis_relative_direction: Event.AxisRelativeDirection,

            /// enter event
            pub const Enter = struct {
                serial: u32,
                surface: u32,
                surface_x: f32,
                surface_y: f32,
            };

            /// leave event
            pub const Leave = struct {
                serial: u32,
                surface: u32,
            };

            /// pointer motion event
            pub const Motion = struct {
                time: u32,
                surface_x: f32,
                surface_y: f32,
            };

            /// pointer button event
            pub const Button = struct {
                serial: u32,
                time: u32,
                button: u32,
                state: Pointer.ButtonState,
            };

            /// axis event
            pub const Axis = struct {
                time: u32,
                axis: Pointer.Axis,
                value: f32,
            };

            /// end of a pointer event sequence
            pub const Frame = struct {};

            /// axis source event
            pub const AxisSource = struct {
                axis_source: Pointer.AxisSource,
            };

            /// axis stop event
            pub const AxisStop = struct {
                time: u32,
                axis: Pointer.Axis,
            };

            /// axis click event
            pub const AxisDiscrete = struct {
                axis: Pointer.Axis,
                discrete: i32,
            };

            /// axis high-resolution scroll event
            pub const AxisValue120 = struct {
                axis: Pointer.Axis,
                value120: i32,
            };

            /// axis relative physical direction event
            pub const AxisRelativeDirection = struct {
                axis: Pointer.Axis,
                direction: Pointer.AxisRelativeDirection,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .enter = try msg.parse_data(Event.Enter, data) },
                    1 => .{ .leave = try msg.parse_data(Event.Leave, data) },
                    2 => .{ .motion = try msg.parse_data(Event.Motion, data) },
                    3 => .{ .button = try msg.parse_data(Event.Button, data) },
                    4 => .{ .axis = try msg.parse_data(Event.Axis, data) },
                    5 => .{ .frame = try msg.parse_data(Event.Frame, data) },
                    6 => .{ .axis_source = try msg.parse_data(Event.AxisSource, data) },
                    7 => .{ .axis_stop = try msg.parse_data(Event.AxisStop, data) },
                    8 => .{ .axis_discrete = try msg.parse_data(Event.AxisDiscrete, data) },
                    9 => .{ .axis_value120 = try msg.parse_data(Event.AxisValue120, data) },
                    10 => .{ .axis_relative_direction = try msg.parse_data(Event.AxisRelativeDirection, data) },
                    else => {
                        log.warn("Unknown pointer event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// keyboard input device
    pub const Keyboard = struct {
        pub const name: [:0]const u8 = "wl_keyboard";

        version: u32 = 10,
        id: u32,

        /// keyboard mapping format
        pub const KeymapFormat = enum(u32) {
            /// no keymap; client must understand how to interpret the raw keycode
            no_keymap = 0,
            /// libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
            xkb_v1 = 1,
        };
        /// physical key state
        pub const KeyState = enum(u32) {
            /// key is not pressed
            released = 0,
            /// key is pressed
            pressed = 1,
            /// key was repeated
            repeated = 2,
        };
        pub const release_params = struct {
            pub const op = 0;
        };

        /// release the keyboard object
        pub fn release(
            self: *const Keyboard,
            writer: anytype,
            params: release_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            keymap: Event.Keymap,
            enter: Event.Enter,
            leave: Event.Leave,
            key: Event.Key,
            modifiers: Event.Modifiers,
            repeat_info: Event.RepeatInfo,

            /// keyboard mapping
            pub const Keymap = struct {
                format: Keyboard.KeymapFormat,
                fd: std.posix.fd_t,
                size: u32,
            };

            /// enter event
            pub const Enter = struct {
                serial: u32,
                surface: u32,
                keys: []const u8,
            };

            /// leave event
            pub const Leave = struct {
                serial: u32,
                surface: u32,
            };

            /// key event
            pub const Key = struct {
                serial: u32,
                time: u32,
                key: u32,
                state: Keyboard.KeyState,
            };

            /// modifier and group state
            pub const Modifiers = struct {
                serial: u32,
                mods_depressed: u32,
                mods_latched: u32,
                mods_locked: u32,
                group: u32,
            };

            /// repeat rate and delay
            pub const RepeatInfo = struct {
                rate: i32,
                delay: i32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .keymap = try msg.parse_data(Event.Keymap, data) },
                    1 => .{ .enter = try msg.parse_data(Event.Enter, data) },
                    2 => .{ .leave = try msg.parse_data(Event.Leave, data) },
                    3 => .{ .key = try msg.parse_data(Event.Key, data) },
                    4 => .{ .modifiers = try msg.parse_data(Event.Modifiers, data) },
                    5 => .{ .repeat_info = try msg.parse_data(Event.RepeatInfo, data) },
                    else => {
                        log.warn("Unknown keyboard event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// touchscreen input device
    pub const Touch = struct {
        pub const name: [:0]const u8 = "wl_touch";

        version: u32 = 10,
        id: u32,

        pub const release_params = struct {
            pub const op = 0;
        };

        /// release the touch object
        pub fn release(
            self: *const Touch,
            writer: anytype,
            params: release_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            down: Event.Down,
            up: Event.Up,
            motion: Event.Motion,
            frame: Event.Frame,
            cancel: Event.Cancel,
            shape: Event.Shape,
            orientation: Event.Orientation,

            /// touch down event and beginning of a touch sequence
            pub const Down = struct {
                serial: u32,
                time: u32,
                surface: u32,
                id: i32,
                x: f32,
                y: f32,
            };

            /// end of a touch event sequence
            pub const Up = struct {
                serial: u32,
                time: u32,
                id: i32,
            };

            /// update of touch point coordinates
            pub const Motion = struct {
                time: u32,
                id: i32,
                x: f32,
                y: f32,
            };

            /// end of touch frame event
            pub const Frame = struct {};

            /// touch session cancelled
            pub const Cancel = struct {};

            /// update shape of touch point
            pub const Shape = struct {
                id: i32,
                major: f32,
                minor: f32,
            };

            /// update orientation of touch point
            pub const Orientation = struct {
                id: i32,
                orientation: f32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .down = try msg.parse_data(Event.Down, data) },
                    1 => .{ .up = try msg.parse_data(Event.Up, data) },
                    2 => .{ .motion = try msg.parse_data(Event.Motion, data) },
                    3 => .{ .frame = try msg.parse_data(Event.Frame, data) },
                    4 => .{ .cancel = try msg.parse_data(Event.Cancel, data) },
                    5 => .{ .shape = try msg.parse_data(Event.Shape, data) },
                    6 => .{ .orientation = try msg.parse_data(Event.Orientation, data) },
                    else => {
                        log.warn("Unknown touch event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// compositor output region
    pub const Output = struct {
        pub const name: [:0]const u8 = "wl_output";

        version: u32 = 4,
        id: u32,

        /// subpixel geometry information
        pub const Subpixel = enum(u32) {
            /// unknown geometry
            unknown = 0,
            /// no geometry
            none = 1,
            /// horizontal RGB
            horizontal_rgb = 2,
            /// horizontal BGR
            horizontal_bgr = 3,
            /// vertical RGB
            vertical_rgb = 4,
            /// vertical BGR
            vertical_bgr = 5,
        };
        /// transformation applied to buffer contents
        pub const Transform = enum(u32) {
            /// no transform
            normal = 0,
            /// 90 degrees counter-clockwise
            @"90" = 1,
            /// 180 degrees counter-clockwise
            @"180" = 2,
            /// 270 degrees counter-clockwise
            @"270" = 3,
            /// 180 degree flip around a vertical axis
            flipped = 4,
            /// flip and rotate 90 degrees counter-clockwise
            flipped_90 = 5,
            /// flip and rotate 180 degrees counter-clockwise
            flipped_180 = 6,
            /// flip and rotate 270 degrees counter-clockwise
            flipped_270 = 7,
        };
        /// mode information
        pub const Mode = packed struct(u32) {
            /// indicates this is the current mode
            current: bool = false,
            /// indicates this is the preferred mode
            preferred: bool = false,
            __reserved_bit_2: bool = false,
            __reserved_bit_3: bool = false,
            __reserved_bit_4: bool = false,
            __reserved_bit_5: bool = false,
            __reserved_bit_6: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        pub const release_params = struct {
            pub const op = 0;
        };

        /// release the output object
        pub fn release(
            self: *const Output,
            writer: anytype,
            params: release_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const Event = union(enum) {
            geometry: Event.Geometry,
            mode: Event.Mode,
            done: Event.Done,
            scale: Event.Scale,
            name: Event.Name,
            description: Event.Description,

            /// properties of the output
            pub const Geometry = struct {
                x: i32,
                y: i32,
                physical_width: i32,
                physical_height: i32,
                subpixel: Output.Subpixel,
                make: [:0]const u8,
                model: [:0]const u8,
                transform: Output.Transform,
            };

            /// advertise available modes for the output
            pub const Mode = struct {
                flags: Output.Mode,
                width: i32,
                height: i32,
                refresh: i32,
            };

            /// sent all information about output
            pub const Done = struct {};

            /// output scaling properties
            pub const Scale = struct {
                factor: i32,
            };

            /// name of this output
            pub const Name = struct {
                name: [:0]const u8,
            };

            /// human-readable description of this output
            pub const Description = struct {
                description: [:0]const u8,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .geometry = try msg.parse_data(Event.Geometry, data) },
                    1 => .{ .mode = try msg.parse_data(Event.Mode, data) },
                    2 => .{ .done = try msg.parse_data(Event.Done, data) },
                    3 => .{ .scale = try msg.parse_data(Event.Scale, data) },
                    4 => .{ .name = try msg.parse_data(Event.Name, data) },
                    5 => .{ .description = try msg.parse_data(Event.Description, data) },
                    else => {
                        log.warn("Unknown output event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// region interface
    pub const Region = struct {
        pub const name: [:0]const u8 = "wl_region";

        version: u32 = 1,
        id: u32,

        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy region
        pub fn destroy(
            self: *const Region,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const add_params = struct {
            pub const op = 1;
            /// region-local x coordinate
            x: i32,
            /// region-local y coordinate
            y: i32,
            /// rectangle width
            width: i32,
            /// rectangle height
            height: i32,
        };

        /// add rectangle to region
        pub fn add(
            self: *const Region,
            writer: anytype,
            params: add_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const subtract_params = struct {
            pub const op = 2;
            /// region-local x coordinate
            x: i32,
            /// region-local y coordinate
            y: i32,
            /// rectangle width
            width: i32,
            /// rectangle height
            height: i32,
        };

        /// subtract rectangle from region
        pub fn subtract(
            self: *const Region,
            writer: anytype,
            params: subtract_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }
    };

    /// sub-surface compositing
    pub const Subcompositor = struct {
        pub const name: [:0]const u8 = "wl_subcompositor";

        version: u32 = 1,
        id: u32,
        pub const Error = enum(u32) {
            /// the to-be sub-surface is invalid
            bad_surface = 0,
            /// the to-be sub-surface parent is invalid
            bad_parent = 1,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// unbind from the subcompositor interface
        pub fn destroy(
            self: *const Subcompositor,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const get_subsurface_params = struct {
            pub const op = 1;
            /// the new sub-surface object ID
            id: ?u32, // id for new wl_subsurface object
            /// the surface to be turned into a sub-surface
            surface: u32,
            /// the parent surface
            parent: u32,
        };

        /// give a surface the role sub-surface
        pub fn get_subsurface(
            self: *const Subcompositor,
            writer: anytype,
            params: get_subsurface_params,
        ) !wl_subsurface {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, wl_subsurface);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(wl_subsurface);
                    var write_params: get_subsurface_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }
    };

    /// sub-surface interface to a wl_surface
    pub const Subsurface = struct {
        pub const name: [:0]const u8 = "wl_subsurface";

        version: u32 = 1,
        id: u32,
        pub const Error = enum(u32) {
            /// wl_surface is not a sibling or the parent
            bad_surface = 0,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// remove sub-surface interface
        pub fn destroy(
            self: *const Subsurface,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const set_position_params = struct {
            pub const op = 1;
            /// x coordinate in the parent surface
            x: i32,
            /// y coordinate in the parent surface
            y: i32,
        };

        /// reposition the sub-surface
        pub fn set_position(
            self: *const Subsurface,
            writer: anytype,
            params: set_position_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const place_above_params = struct {
            pub const op = 2;
            /// the reference surface
            sibling: u32,
        };

        /// restack the sub-surface
        pub fn place_above(
            self: *const Subsurface,
            writer: anytype,
            params: place_above_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const place_below_params = struct {
            pub const op = 3;
            /// the reference surface
            sibling: u32,
        };

        /// restack the sub-surface
        pub fn place_below(
            self: *const Subsurface,
            writer: anytype,
            params: place_below_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_sync_params = struct {
            pub const op = 4;
        };

        /// set sub-surface to synchronized mode
        pub fn set_sync(
            self: *const Subsurface,
            writer: anytype,
            params: set_sync_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_desync_params = struct {
            pub const op = 5;
        };

        /// set sub-surface to desynchronized mode
        pub fn set_desync(
            self: *const Subsurface,
            writer: anytype,
            params: set_desync_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }
    };
};
const wl_display = wayland.Display;
const wl_registry = wayland.Registry;
const wl_callback = wayland.Callback;
const wl_compositor = wayland.Compositor;
const wl_shm_pool = wayland.ShmPool;
const wl_shm = wayland.Shm;
const wl_buffer = wayland.Buffer;
const wl_data_offer = wayland.DataOffer;
const wl_data_source = wayland.DataSource;
const wl_data_device = wayland.DataDevice;
const wl_data_device_manager = wayland.DataDeviceManager;
const wl_shell = wayland.Shell;
const wl_shell_surface = wayland.ShellSurface;
const wl_surface = wayland.Surface;
const wl_seat = wayland.Seat;
const wl_pointer = wayland.Pointer;
const wl_keyboard = wayland.Keyboard;
const wl_touch = wayland.Touch;
const wl_output = wayland.Output;
const wl_region = wayland.Region;
const wl_subcompositor = wayland.Subcompositor;
const wl_subsurface = wayland.Subsurface;

// ----------------------- END PROTOCOL: wayland --------------------------

// ----------------------- BEGIN PROTOCOL: xdg_decoration_unstable_v1 --------------------------

pub const xdg_decoration_unstable_v1 = struct {
    const log = std.log.scoped(.xdg_decoration_unstable_v1);

    /// window decoration manager
    pub const DecorationManagerV1 = struct {
        pub const name: [:0]const u8 = "zxdg_decoration_manager_v1";

        version: u32 = 1,
        id: u32,

        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy the decoration manager object
        pub fn destroy(
            self: *const DecorationManagerV1,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const get_toplevel_decoration_params = struct {
            pub const op = 1;
            id: ?u32, // id for new zxdg_toplevel_decoration_v1 object
            toplevel: u32,
        };

        /// create a new toplevel decoration object
        pub fn get_toplevel_decoration(
            self: *const DecorationManagerV1,
            writer: anytype,
            params: get_toplevel_decoration_params,
        ) !zxdg_toplevel_decoration_v1 {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, zxdg_toplevel_decoration_v1);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(zxdg_toplevel_decoration_v1);
                    var write_params: get_toplevel_decoration_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }
    };

    /// decoration object for a toplevel surface
    pub const ToplevelDecorationV1 = struct {
        pub const name: [:0]const u8 = "zxdg_toplevel_decoration_v1";

        version: u32 = 1,
        id: u32,
        pub const Error = enum(u32) {
            /// xdg_toplevel has a buffer attached before configure
            unconfigured_buffer = 0,
            /// xdg_toplevel already has a decoration object
            already_constructed = 1,
            /// xdg_toplevel destroyed before the decoration object
            orphaned = 2,
            /// invalid mode
            invalid_mode = 3,
        };
        /// window decoration modes
        pub const Mode = enum(u32) {
            /// no server-side window decoration
            client_side = 1,
            /// server-side window decoration
            server_side = 2,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy the decoration object
        pub fn destroy(
            self: *const ToplevelDecorationV1,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const set_mode_params = struct {
            pub const op = 1;
            /// the decoration mode
            mode: Mode,
        };

        /// set the decoration mode
        pub fn set_mode(
            self: *const ToplevelDecorationV1,
            writer: anytype,
            params: set_mode_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const unset_mode_params = struct {
            pub const op = 2;
        };

        /// unset the decoration mode
        pub fn unset_mode(
            self: *const ToplevelDecorationV1,
            writer: anytype,
            params: unset_mode_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            configure: Event.Configure,

            /// notify a decoration mode change
            pub const Configure = struct {
                mode: ToplevelDecorationV1.Mode,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .configure = try msg.parse_data(Event.Configure, data) },
                    else => {
                        log.warn("Unknown toplevel_decoration_v1 event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };
};
const zxdg_decoration_manager_v1 = xdg_decoration_unstable_v1.DecorationManagerV1;
const zxdg_toplevel_decoration_v1 = xdg_decoration_unstable_v1.ToplevelDecorationV1;

// ----------------------- END PROTOCOL: xdg_decoration_unstable_v1 --------------------------

// ----------------------- BEGIN PROTOCOL: xdg_shell --------------------------

pub const xdg_shell = struct {
    const log = std.log.scoped(.xdg_shell);

    /// create desktop-style surfaces
    pub const WmBase = struct {
        pub const name: [:0]const u8 = "xdg_wm_base";

        version: u32 = 6,
        id: u32,
        pub const Error = enum(u32) {
            /// given wl_surface has another role
            role = 0,
            /// xdg_wm_base was destroyed before children
            defunct_surfaces = 1,
            /// the client tried to map or destroy a non-topmost popup
            not_the_topmost_popup = 2,
            /// the client specified an invalid popup parent surface
            invalid_popup_parent = 3,
            /// the client provided an invalid surface state
            invalid_surface_state = 4,
            /// the client provided an invalid positioner
            invalid_positioner = 5,
            /// the client didnt respond to a ping event in time
            unresponsive = 6,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy xdg_wm_base
        pub fn destroy(
            self: *const WmBase,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const create_positioner_params = struct {
            pub const op = 1;
            id: ?u32, // id for new xdg_positioner object
        };

        /// create a positioner object
        pub fn create_positioner(
            self: *const WmBase,
            writer: anytype,
            params: create_positioner_params,
        ) !xdg_positioner {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, xdg_positioner);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(xdg_positioner);
                    var write_params: create_positioner_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_xdg_surface_params = struct {
            pub const op = 2;
            id: ?u32, // id for new xdg_surface object
            surface: u32,
        };

        /// create a shell surface from a surface
        pub fn get_xdg_surface(
            self: *const WmBase,
            writer: anytype,
            params: get_xdg_surface_params,
        ) !xdg_surface {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, xdg_surface);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(xdg_surface);
                    var write_params: get_xdg_surface_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const pong_params = struct {
            pub const op = 3;
            /// serial of the ping event
            serial: u32,
        };

        /// respond to a ping event
        pub fn pong(
            self: *const WmBase,
            writer: anytype,
            params: pong_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            ping: Event.Ping,

            /// check if the client is alive
            pub const Ping = struct {
                serial: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .ping = try msg.parse_data(Event.Ping, data) },
                    else => {
                        log.warn("Unknown wm_base event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// child surface positioner
    pub const Positioner = struct {
        pub const name: [:0]const u8 = "xdg_positioner";

        version: u32 = 6,
        id: u32,
        pub const Error = enum(u32) {
            /// invalid input provided
            invalid_input = 0,
        };
        pub const Anchor = enum(u32) {
            none = 0,
            top = 1,
            bottom = 2,
            left = 3,
            right = 4,
            top_left = 5,
            bottom_left = 6,
            top_right = 7,
            bottom_right = 8,
        };
        pub const Gravity = enum(u32) {
            none = 0,
            top = 1,
            bottom = 2,
            left = 3,
            right = 4,
            top_left = 5,
            bottom_left = 6,
            top_right = 7,
            bottom_right = 8,
        };
        /// constraint adjustments
        pub const ConstraintAdjustment = packed struct(u32) {
            none: bool = false,
            slide_x: bool = false,
            slide_y: bool = false,
            flip_x: bool = false,
            flip_y: bool = false,
            resize_x: bool = false,
            resize_y: bool = false,
            __reserved_bit_7: bool = false,
            __reserved_bit_8: bool = false,
            __reserved_bit_9: bool = false,
            __reserved_bit_10: bool = false,
            __reserved_bit_11: bool = false,
            __reserved_bit_12: bool = false,
            __reserved_bit_13: bool = false,
            __reserved_bit_14: bool = false,
            __reserved_bit_15: bool = false,
            __reserved_bit_16: bool = false,
            __reserved_bit_17: bool = false,
            __reserved_bit_18: bool = false,
            __reserved_bit_19: bool = false,
            __reserved_bit_20: bool = false,
            __reserved_bit_21: bool = false,
            __reserved_bit_22: bool = false,
            __reserved_bit_23: bool = false,
            __reserved_bit_24: bool = false,
            __reserved_bit_25: bool = false,
            __reserved_bit_26: bool = false,
            __reserved_bit_27: bool = false,
            __reserved_bit_28: bool = false,
            __reserved_bit_29: bool = false,
            __reserved_bit_30: bool = false,
            __reserved_bit_31: bool = false,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy the xdg_positioner object
        pub fn destroy(
            self: *const Positioner,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const set_size_params = struct {
            pub const op = 1;
            /// width of positioned rectangle
            width: i32,
            /// height of positioned rectangle
            height: i32,
        };

        /// set the size of the to-be positioned rectangle
        pub fn set_size(
            self: *const Positioner,
            writer: anytype,
            params: set_size_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_anchor_rect_params = struct {
            pub const op = 2;
            /// x position of anchor rectangle
            x: i32,
            /// y position of anchor rectangle
            y: i32,
            /// width of anchor rectangle
            width: i32,
            /// height of anchor rectangle
            height: i32,
        };

        /// set the anchor rectangle within the parent surface
        pub fn set_anchor_rect(
            self: *const Positioner,
            writer: anytype,
            params: set_anchor_rect_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_anchor_params = struct {
            pub const op = 3;
            /// anchor
            anchor: Anchor,
        };

        /// set anchor rectangle anchor
        pub fn set_anchor(
            self: *const Positioner,
            writer: anytype,
            params: set_anchor_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_gravity_params = struct {
            pub const op = 4;
            /// gravity direction
            gravity: Gravity,
        };

        /// set child surface gravity
        pub fn set_gravity(
            self: *const Positioner,
            writer: anytype,
            params: set_gravity_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_constraint_adjustment_params = struct {
            pub const op = 5;
            /// bit mask of constraint adjustments
            constraint_adjustment: ConstraintAdjustment,
        };

        /// set the adjustment to be done when constrained
        pub fn set_constraint_adjustment(
            self: *const Positioner,
            writer: anytype,
            params: set_constraint_adjustment_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_offset_params = struct {
            pub const op = 6;
            /// surface position x offset
            x: i32,
            /// surface position y offset
            y: i32,
        };

        /// set surface position offset
        pub fn set_offset(
            self: *const Positioner,
            writer: anytype,
            params: set_offset_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_reactive_params = struct {
            pub const op = 7;
        };

        /// continuously reconstrain the surface
        pub fn set_reactive(
            self: *const Positioner,
            writer: anytype,
            params: set_reactive_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_parent_size_params = struct {
            pub const op = 8;
            /// future window geometry width of parent
            parent_width: i32,
            /// future window geometry height of parent
            parent_height: i32,
        };

        ///
        pub fn set_parent_size(
            self: *const Positioner,
            writer: anytype,
            params: set_parent_size_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_parent_configure_params = struct {
            pub const op = 9;
            /// serial of parent configure event
            serial: u32,
        };

        /// set parent configure this is a response to
        pub fn set_parent_configure(
            self: *const Positioner,
            writer: anytype,
            params: set_parent_configure_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }
    };

    /// desktop user interface surface base interface
    pub const Surface = struct {
        pub const name: [:0]const u8 = "xdg_surface";

        version: u32 = 6,
        id: u32,
        pub const Error = enum(u32) {
            /// Surface was not fully constructed
            not_constructed = 1,
            /// Surface was already constructed
            already_constructed = 2,
            /// Attaching a buffer to an unconfigured surface
            unconfigured_buffer = 3,
            /// Invalid serial number when acking a configure event
            invalid_serial = 4,
            /// Width or height was zero or negative
            invalid_size = 5,
            /// Surface was destroyed before its role object
            defunct_role_object = 6,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy the xdg_surface
        pub fn destroy(
            self: *const Surface,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const get_toplevel_params = struct {
            pub const op = 1;
            id: ?u32, // id for new xdg_toplevel object
        };

        /// assign the xdg_toplevel surface role
        pub fn get_toplevel(
            self: *const Surface,
            writer: anytype,
            params: get_toplevel_params,
        ) !xdg_toplevel {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, xdg_toplevel);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(xdg_toplevel);
                    var write_params: get_toplevel_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const get_popup_params = struct {
            pub const op = 2;
            id: ?u32, // id for new xdg_popup object
            parent: u32,
            positioner: u32,
        };

        /// assign the xdg_popup surface role
        pub fn get_popup(
            self: *const Surface,
            writer: anytype,
            params: get_popup_params,
        ) !xdg_popup {
            const res = init: {
                if (params.id) |id| {
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    interface.registry.insert(id, xdg_popup);
                    break :init .{ .id = id };
                } else {
                    const _res = try interface.registry.register(xdg_popup);
                    var write_params: get_popup_params = params;
                    write_params.id = _res.id;
                    try msg.write(writer, @TypeOf(params), params, self.id);
                    break :init .{ .id = params.id };
                }
            };
            return res;
        }

        pub const set_window_geometry_params = struct {
            pub const op = 3;
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        };

        /// set the new window geometry
        pub fn set_window_geometry(
            self: *const Surface,
            writer: anytype,
            params: set_window_geometry_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const ack_configure_params = struct {
            pub const op = 4;
            /// the serial from the configure event
            serial: u32,
        };

        /// ack a configure event
        pub fn ack_configure(
            self: *const Surface,
            writer: anytype,
            params: ack_configure_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            configure: Event.Configure,

            /// suggest a surface change
            pub const Configure = struct {
                serial: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .configure = try msg.parse_data(Event.Configure, data) },
                    else => {
                        log.warn("Unknown surface event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// toplevel surface
    pub const Toplevel = struct {
        pub const name: [:0]const u8 = "xdg_toplevel";

        version: u32 = 6,
        id: u32,
        pub const Error = enum(u32) {
            /// provided value is not a valid variant of the resize_edge enum
            invalid_resize_edge = 0,
            /// invalid parent toplevel
            invalid_parent = 1,
            /// client provided an invalid min or max size
            invalid_size = 2,
        };
        /// edge values for resizing
        pub const ResizeEdge = enum(u32) {
            none = 0,
            top = 1,
            bottom = 2,
            left = 4,
            top_left = 5,
            bottom_left = 6,
            right = 8,
            top_right = 9,
            bottom_right = 10,
        };
        /// types of state on the surface
        pub const State = enum(u32) {
            /// the surface is maximized
            maximized = 1,
            /// the surface is fullscreen
            fullscreen = 2,
            /// the surface is being resized
            resizing = 3,
            /// the surface is now activated
            activated = 4,
            tiled_left = 5,
            tiled_right = 6,
            tiled_top = 7,
            tiled_bottom = 8,
            suspended = 9,
        };
        pub const WmCapabilities = enum(u32) {
            /// show_window_menu is available
            window_menu = 1,
            /// set_maximized and unset_maximized are available
            maximize = 2,
            /// set_fullscreen and unset_fullscreen are available
            fullscreen = 3,
            /// set_minimized is available
            minimize = 4,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// destroy the xdg_toplevel
        pub fn destroy(
            self: *const Toplevel,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const set_parent_params = struct {
            pub const op = 1;
            parent: u32,
        };

        /// set the parent of this surface
        pub fn set_parent(
            self: *const Toplevel,
            writer: anytype,
            params: set_parent_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_title_params = struct {
            pub const op = 2;
            title: [:0]const u8,
        };

        /// set surface title
        pub fn set_title(
            self: *const Toplevel,
            writer: anytype,
            params: set_title_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_app_id_params = struct {
            pub const op = 3;
            app_id: [:0]const u8,
        };

        /// set application ID
        pub fn set_app_id(
            self: *const Toplevel,
            writer: anytype,
            params: set_app_id_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const show_window_menu_params = struct {
            pub const op = 4;
            /// the wl_seat of the user event
            seat: u32,
            /// the serial of the user event
            serial: u32,
            /// the x position to pop up the window menu at
            x: i32,
            /// the y position to pop up the window menu at
            y: i32,
        };

        /// show the window menu
        pub fn show_window_menu(
            self: *const Toplevel,
            writer: anytype,
            params: show_window_menu_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const move_params = struct {
            pub const op = 5;
            /// the wl_seat of the user event
            seat: u32,
            /// the serial of the user event
            serial: u32,
        };

        /// start an interactive move
        pub fn move(
            self: *const Toplevel,
            writer: anytype,
            params: move_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const resize_params = struct {
            pub const op = 6;
            /// the wl_seat of the user event
            seat: u32,
            /// the serial of the user event
            serial: u32,
            /// which edge or corner is being dragged
            edges: ResizeEdge,
        };

        /// start an interactive resize
        pub fn resize(
            self: *const Toplevel,
            writer: anytype,
            params: resize_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_max_size_params = struct {
            pub const op = 7;
            width: i32,
            height: i32,
        };

        /// set the maximum size
        pub fn set_max_size(
            self: *const Toplevel,
            writer: anytype,
            params: set_max_size_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_min_size_params = struct {
            pub const op = 8;
            width: i32,
            height: i32,
        };

        /// set the minimum size
        pub fn set_min_size(
            self: *const Toplevel,
            writer: anytype,
            params: set_min_size_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_maximized_params = struct {
            pub const op = 9;
        };

        /// maximize the window
        pub fn set_maximized(
            self: *const Toplevel,
            writer: anytype,
            params: set_maximized_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const unset_maximized_params = struct {
            pub const op = 10;
        };

        /// unmaximize the window
        pub fn unset_maximized(
            self: *const Toplevel,
            writer: anytype,
            params: unset_maximized_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_fullscreen_params = struct {
            pub const op = 11;
            output: u32,
        };

        /// set the window as fullscreen on an output
        pub fn set_fullscreen(
            self: *const Toplevel,
            writer: anytype,
            params: set_fullscreen_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const unset_fullscreen_params = struct {
            pub const op = 12;
        };

        /// unset the window as fullscreen
        pub fn unset_fullscreen(
            self: *const Toplevel,
            writer: anytype,
            params: unset_fullscreen_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const set_minimized_params = struct {
            pub const op = 13;
        };

        /// set the window as minimized
        pub fn set_minimized(
            self: *const Toplevel,
            writer: anytype,
            params: set_minimized_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            configure: Event.Configure,
            close: Event.Close,
            configure_bounds: Event.ConfigureBounds,
            wm_capabilities: Event.WmCapabilities,

            /// suggest a surface change
            pub const Configure = struct {
                width: i32,
                height: i32,
                states: []const u8,
            };

            /// surface wants to be closed
            pub const Close = struct {};

            /// recommended window geometry bounds
            pub const ConfigureBounds = struct {
                width: i32,
                height: i32,
            };

            /// compositor capabilities
            pub const WmCapabilities = struct {
                capabilities: []const u8,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .configure = try msg.parse_data(Event.Configure, data) },
                    1 => .{ .close = try msg.parse_data(Event.Close, data) },
                    2 => .{ .configure_bounds = try msg.parse_data(Event.ConfigureBounds, data) },
                    3 => .{ .wm_capabilities = try msg.parse_data(Event.WmCapabilities, data) },
                    else => {
                        log.warn("Unknown toplevel event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };

    /// short-lived, popup surfaces for menus
    pub const Popup = struct {
        pub const name: [:0]const u8 = "xdg_popup";

        version: u32 = 6,
        id: u32,
        pub const Error = enum(u32) {
            /// tried to grab after being mapped
            invalid_grab = 0,
        };
        pub const destroy_params = struct {
            pub const op = 0;
        };

        /// remove xdg_popup interface
        pub fn destroy(
            self: *const Popup,
            writer: anytype,
            params: destroy_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
            try interface.registry.remove(self.*);
        }

        pub const grab_params = struct {
            pub const op = 1;
            /// the wl_seat of the user event
            seat: u32,
            /// the serial of the user event
            serial: u32,
        };

        /// make the popup take an explicit grab
        pub fn grab(
            self: *const Popup,
            writer: anytype,
            params: grab_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const reposition_params = struct {
            pub const op = 2;
            positioner: u32,
            /// reposition request token
            token: u32,
        };

        /// recalculate the popup's location
        pub fn reposition(
            self: *const Popup,
            writer: anytype,
            params: reposition_params,
        ) !void {
            try msg.write(writer, @TypeOf(params), params, self.id);
        }

        pub const Event = union(enum) {
            configure: Event.Configure,
            popup_done: Event.PopupDone,
            repositioned: Event.Repositioned,

            /// configure the popup surface
            pub const Configure = struct {
                x: i32,
                y: i32,
                width: i32,
                height: i32,
            };

            /// popup interaction is done
            pub const PopupDone = struct {};

            /// signal the completion of a repositioned request
            pub const Repositioned = struct {
                token: u32,
            };
            pub fn parse(op: u32, data: []const u8) !Event {
                return switch (op) {
                    0 => .{ .configure = try msg.parse_data(Event.Configure, data) },
                    1 => .{ .popup_done = try msg.parse_data(Event.PopupDone, data) },
                    2 => .{ .repositioned = try msg.parse_data(Event.Repositioned, data) },
                    else => {
                        log.warn("Unknown popup event: {d}", .{op});
                        return error.UnknownEvent;
                    },
                };
            }
        };
    };
};
const xdg_wm_base = xdg_shell.WmBase;
const xdg_positioner = xdg_shell.Positioner;
const xdg_surface = xdg_shell.Surface;
const xdg_toplevel = xdg_shell.Toplevel;
const xdg_popup = xdg_shell.Popup;

// ----------------------- END PROTOCOL: xdg_shell --------------------------
