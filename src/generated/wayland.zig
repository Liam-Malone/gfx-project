// WARNING: This file is auto-generated by wl-zig-bindgen.
//          It is recommended that you do NOT edit this file.
//
// TODO: Put a useful message in here when this thing is ready.
//

const std = @import("std");
const log = std.log.scoped(.wayland);

const wl_msg = @import("wl_msg"); // It's assumed that the user provides this module

/// core global object
pub const Display = struct {
    id: u32,
    version: u32 = 1,

    /// global error values
    pub const Error = enum(u32) {
        /// server couldn't find object
        invalid_object = 0,
        /// method doesn't exist on the specified interface or malformed request
        invalid_method = 1,
        /// server is out of memory
        no_memory = 2,
        /// implementation error in compositor
        implementation = 3,
    };
    pub const sync_params = struct {
        pub const op = 0;
        /// callback object for the sync request
        callback: u32,
    };

    /// asynchronous roundtrip
    pub fn sync(self: *const Display, writer: anytype, params: sync_params) !void {
        log.debug("    Sending Display::sync {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const get_registry_params = struct {
        pub const op = 1;
        /// global registry object
        registry: u32,
    };

    /// get global registry object
    pub fn get_registry(self: *const Display, writer: anytype, params: get_registry_params) !void {
        log.debug("    Sending Display::get_registry {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        @"error": Event.Error,
        delete_id: Event.DeleteId,

        /// fatal error event
        pub const Error = struct {
            object_id: u32,
            code: u32,
            message: [:0]const u8,
        };

        /// acknowledge object ID deletion
        pub const DeleteId = struct {
            id: u32,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .@"error" = try wl_msg.parse_data(sock, Event.Error, data) },
                1 => .{ .delete_id = try wl_msg.parse_data(sock, Event.DeleteId, data) },
                else => {
                    log.warn("Unknown display event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// global registry object
pub const Registry = struct {
    id: u32,
    version: u32 = 1,

    pub const bind_params = struct {
        pub const op = 0;
        /// unique numeric name of the object
        name: u32,
        /// bounded object
        id_interface: [:0]const u8,
        id_interface_version: u32,
        id: u32,
    };

    /// bind an object to the display
    pub fn bind(self: *const Registry, writer: anytype, params: bind_params) !void {
        log.debug("    Sending Registry::bind {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        global: Event.Global,
        global_remove: Event.GlobalRemove,

        /// announce global object
        pub const Global = struct {
            name: u32,
            interface: [:0]const u8,
            version: u32,
        };

        /// announce removal of global object
        pub const GlobalRemove = struct {
            name: u32,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .global = try wl_msg.parse_data(sock, Event.Global, data) },
                1 => .{ .global_remove = try wl_msg.parse_data(sock, Event.GlobalRemove, data) },
                else => {
                    log.warn("Unknown registry event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// callback object
pub const Callback = struct {
    id: u32,
    version: u32 = 1,
    pub const Event = union(enum) {
        done: Event.Done,

        /// done event
        pub const Done = struct {
            callback_data: u32,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .done = try wl_msg.parse_data(sock, Event.Done, data) },
                else => {
                    log.warn("Unknown callback event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// the compositor singleton
pub const Compositor = struct {
    id: u32,
    version: u32 = 6,

    pub const create_surface_params = struct {
        pub const op = 0;
        /// the new surface
        id: u32,
    };

    /// create new surface
    pub fn create_surface(self: *const Compositor, writer: anytype, params: create_surface_params) !void {
        log.debug("    Sending Compositor::create_surface {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const create_region_params = struct {
        pub const op = 1;
        /// the new region
        id: u32,
    };

    /// create new region
    pub fn create_region(self: *const Compositor, writer: anytype, params: create_region_params) !void {
        log.debug("    Sending Compositor::create_region {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
};

/// a shared memory pool
pub const ShmPool = struct {
    id: u32,
    version: u32 = 2,

    pub const create_buffer_params = struct {
        pub const op = 0;
        /// buffer to create
        id: u32,
        /// buffer byte offset within the pool
        offset: i32,
        /// buffer width, in pixels
        width: i32,
        /// buffer height, in pixels
        height: i32,
        /// number of bytes from the beginning of one row to the beginning of the next row
        stride: i32,
        /// buffer pixel format
        format: Shm.Format,
    };

    /// create a buffer from the pool
    pub fn create_buffer(self: *const ShmPool, writer: anytype, params: create_buffer_params) !void {
        log.debug("    Sending ShmPool::create_buffer {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const destroy_params = struct {
        pub const op = 1;
    };

    /// destroy the pool
    pub fn destroy(self: *const ShmPool, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending ShmPool::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const resize_params = struct {
        pub const op = 2;
        /// new size of the pool, in bytes
        size: i32,
    };

    /// change the size of the pool mapping
    pub fn resize(self: *const ShmPool, writer: anytype, params: resize_params) !void {
        log.debug("    Sending ShmPool::resize {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
};

/// shared memory support
pub const Shm = struct {
    id: u32,
    version: u32 = 2,

    /// wl_shm error values
    pub const Error = enum(u32) {
        /// buffer format is not known
        invalid_format = 0,
        /// invalid size or stride during pool or buffer creation
        invalid_stride = 1,
        /// mmapping the file descriptor failed
        invalid_fd = 2,
    };
    /// pixel formats
    pub const Format = enum(u32) {
        /// 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
        argb8888 = 0,
        /// 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
        xrgb8888 = 1,
        /// 8-bit color index format, [7:0] C
        c8 = 0x20203843,
        /// 8-bit RGB format, [7:0] R:G:B 3:3:2
        rgb332 = 0x38424752,
        /// 8-bit BGR format, [7:0] B:G:R 2:3:3
        bgr233 = 0x38524742,
        /// 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
        xrgb4444 = 0x32315258,
        /// 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
        xbgr4444 = 0x32314258,
        /// 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
        rgbx4444 = 0x32315852,
        /// 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
        bgrx4444 = 0x32315842,
        /// 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
        argb4444 = 0x32315241,
        /// 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
        abgr4444 = 0x32314241,
        /// 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
        rgba4444 = 0x32314152,
        /// 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
        bgra4444 = 0x32314142,
        /// 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
        xrgb1555 = 0x35315258,
        /// 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
        xbgr1555 = 0x35314258,
        /// 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
        rgbx5551 = 0x35315852,
        /// 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
        bgrx5551 = 0x35315842,
        /// 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
        argb1555 = 0x35315241,
        /// 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
        abgr1555 = 0x35314241,
        /// 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
        rgba5551 = 0x35314152,
        /// 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
        bgra5551 = 0x35314142,
        /// 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
        rgb565 = 0x36314752,
        /// 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
        bgr565 = 0x36314742,
        /// 24-bit RGB format, [23:0] R:G:B little endian
        rgb888 = 0x34324752,
        /// 24-bit BGR format, [23:0] B:G:R little endian
        bgr888 = 0x34324742,
        /// 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
        xbgr8888 = 0x34324258,
        /// 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
        rgbx8888 = 0x34325852,
        /// 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
        bgrx8888 = 0x34325842,
        /// 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
        abgr8888 = 0x34324241,
        /// 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
        rgba8888 = 0x34324152,
        /// 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
        bgra8888 = 0x34324142,
        /// 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
        xrgb2101010 = 0x30335258,
        /// 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
        xbgr2101010 = 0x30334258,
        /// 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
        rgbx1010102 = 0x30335852,
        /// 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
        bgrx1010102 = 0x30335842,
        /// 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
        argb2101010 = 0x30335241,
        /// 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
        abgr2101010 = 0x30334241,
        /// 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
        rgba1010102 = 0x30334152,
        /// 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
        bgra1010102 = 0x30334142,
        /// packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
        yuyv = 0x56595559,
        /// packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
        yvyu = 0x55595659,
        /// packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
        uyvy = 0x59565955,
        /// packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
        vyuy = 0x59555956,
        /// packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
        ayuv = 0x56555941,
        /// 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
        nv12 = 0x3231564e,
        /// 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
        nv21 = 0x3132564e,
        /// 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
        nv16 = 0x3631564e,
        /// 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
        nv61 = 0x3136564e,
        /// 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
        yuv410 = 0x39565559,
        /// 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
        yvu410 = 0x39555659,
        /// 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
        yuv411 = 0x31315559,
        /// 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
        yvu411 = 0x31315659,
        /// 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
        yuv420 = 0x32315559,
        /// 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
        yvu420 = 0x32315659,
        /// 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
        yuv422 = 0x36315559,
        /// 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
        yvu422 = 0x36315659,
        /// 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
        yuv444 = 0x34325559,
        /// 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
        yvu444 = 0x34325659,
        /// [7:0] R
        r8 = 0x20203852,
        /// [15:0] R little endian
        r16 = 0x20363152,
        /// [15:0] R:G 8:8 little endian
        rg88 = 0x38384752,
        /// [15:0] G:R 8:8 little endian
        gr88 = 0x38385247,
        /// [31:0] R:G 16:16 little endian
        rg1616 = 0x32334752,
        /// [31:0] G:R 16:16 little endian
        gr1616 = 0x32335247,
        /// [63:0] x:R:G:B 16:16:16:16 little endian
        xrgb16161616f = 0x48345258,
        /// [63:0] x:B:G:R 16:16:16:16 little endian
        xbgr16161616f = 0x48344258,
        /// [63:0] A:R:G:B 16:16:16:16 little endian
        argb16161616f = 0x48345241,
        /// [63:0] A:B:G:R 16:16:16:16 little endian
        abgr16161616f = 0x48344241,
        /// [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
        xyuv8888 = 0x56555958,
        /// [23:0] Cr:Cb:Y 8:8:8 little endian
        vuy888 = 0x34325556,
        /// Y followed by U then V, 10:10:10. Non-linear modifier only
        vuy101010 = 0x30335556,
        /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
        y210 = 0x30313259,
        /// [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
        y212 = 0x32313259,
        /// [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
        y216 = 0x36313259,
        /// [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
        y410 = 0x30313459,
        /// [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        y412 = 0x32313459,
        /// [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
        y416 = 0x36313459,
        /// [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
        xvyu2101010 = 0x30335658,
        /// [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
        xvyu12_16161616 = 0x36335658,
        /// [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
        xvyu16161616 = 0x38345658,
        /// [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        y0l0 = 0x304c3059,
        /// [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
        x0l0 = 0x304c3058,
        /// [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        y0l2 = 0x324c3059,
        /// [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
        x0l2 = 0x324c3058,
        yuv420_8bit = 0x38305559,
        yuv420_10bit = 0x30315559,
        xrgb8888_a8 = 0x38415258,
        xbgr8888_a8 = 0x38414258,
        rgbx8888_a8 = 0x38415852,
        bgrx8888_a8 = 0x38415842,
        rgb888_a8 = 0x38413852,
        bgr888_a8 = 0x38413842,
        rgb565_a8 = 0x38413552,
        bgr565_a8 = 0x38413542,
        /// non-subsampled Cr:Cb plane
        nv24 = 0x3432564e,
        /// non-subsampled Cb:Cr plane
        nv42 = 0x3234564e,
        /// 2x1 subsampled Cr:Cb plane, 10 bit per channel
        p210 = 0x30313250,
        /// 2x2 subsampled Cr:Cb plane 10 bits per channel
        p010 = 0x30313050,
        /// 2x2 subsampled Cr:Cb plane 12 bits per channel
        p012 = 0x32313050,
        /// 2x2 subsampled Cr:Cb plane 16 bits per channel
        p016 = 0x36313050,
        /// [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
        axbxgxrx106106106106 = 0x30314241,
        /// 2x2 subsampled Cr:Cb plane
        nv15 = 0x3531564e,
        q410 = 0x30313451,
        q401 = 0x31303451,
        /// [63:0] x:R:G:B 16:16:16:16 little endian
        xrgb16161616 = 0x38345258,
        /// [63:0] x:B:G:R 16:16:16:16 little endian
        xbgr16161616 = 0x38344258,
        /// [63:0] A:R:G:B 16:16:16:16 little endian
        argb16161616 = 0x38345241,
        /// [63:0] A:B:G:R 16:16:16:16 little endian
        abgr16161616 = 0x38344241,
        /// [7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
        c1 = 0x20203143,
        /// [7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
        c2 = 0x20203243,
        /// [7:0] C0:C1 4:4 two pixels/byte
        c4 = 0x20203443,
        /// [7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
        d1 = 0x20203144,
        /// [7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
        d2 = 0x20203244,
        /// [7:0] D0:D1 4:4 two pixels/byte
        d4 = 0x20203444,
        /// [7:0] D
        d8 = 0x20203844,
        /// [7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
        r1 = 0x20203152,
        /// [7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
        r2 = 0x20203252,
        /// [7:0] R0:R1 4:4 two pixels/byte
        r4 = 0x20203452,
        /// [15:0] x:R 6:10 little endian
        r10 = 0x20303152,
        /// [15:0] x:R 4:12 little endian
        r12 = 0x20323152,
        /// [31:0] A:Cr:Cb:Y 8:8:8:8 little endian
        avuy8888 = 0x59555641,
        /// [31:0] X:Cr:Cb:Y 8:8:8:8 little endian
        xvuy8888 = 0x59555658,
        /// 2x2 subsampled Cr:Cb plane 10 bits per channel packed
        p030 = 0x30333050,
    };
    pub const create_pool_params = struct {
        pub const op = 0;
        /// pool to create
        id: u32,
        /// file descriptor for the pool
        fd: wl_msg.FileDescriptor,
        /// pool size, in bytes
        size: i32,
    };

    /// create a shm pool
    pub fn create_pool(self: *const Shm, writer: anytype, params: create_pool_params) !void {
        log.debug("    Sending Shm::create_pool {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const release_params = struct {
        pub const op = 1;
    };

    /// release the shm object
    pub fn release(self: *const Shm, writer: anytype, params: release_params) !void {
        log.debug("    Sending Shm::release {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        format: Event.Format,

        /// pixel format description
        pub const Format = struct {
            format: Shm.Format,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .format = try wl_msg.parse_data(sock, Event.Format, data) },
                else => {
                    log.warn("Unknown shm event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// content for a wl_surface
pub const Buffer = struct {
    id: u32,
    version: u32 = 1,

    pub const destroy_params = struct {
        pub const op = 0;
    };

    /// destroy a buffer
    pub fn destroy(self: *const Buffer, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending Buffer::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        release: Event.Release,

        /// compositor releases buffer
        pub const Release = struct {};
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .release = try wl_msg.parse_data(sock, Event.Release, data) },
                else => {
                    log.warn("Unknown buffer event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// offer to transfer data
pub const DataOffer = struct {
    id: u32,
    version: u32 = 3,
    pub const Error = enum(u32) {
        /// finish request was called untimely
        invalid_finish = 0,
        /// action mask contains invalid values
        invalid_action_mask = 1,
        /// action argument has an invalid value
        invalid_action = 2,
        /// offer doesn't accept this request
        invalid_offer = 3,
    };
    pub const accept_params = struct {
        pub const op = 0;
        /// serial number of the accept request
        serial: u32,
        /// mime type accepted by the client
        mime_type: [:0]const u8,
    };

    /// accept one of the offered mime types
    pub fn accept(self: *const DataOffer, writer: anytype, params: accept_params) !void {
        log.debug("    Sending DataOffer::accept {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const receive_params = struct {
        pub const op = 1;
        /// mime type desired by receiver
        mime_type: [:0]const u8,
        /// file descriptor for data transfer
        fd: wl_msg.FileDescriptor,
    };

    /// request that the data is transferred
    pub fn receive(self: *const DataOffer, writer: anytype, params: receive_params) !void {
        log.debug("    Sending DataOffer::receive {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const destroy_params = struct {
        pub const op = 2;
    };

    /// destroy data offer
    pub fn destroy(self: *const DataOffer, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending DataOffer::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const finish_params = struct {
        pub const op = 3;
    };

    /// the offer will no longer be used
    pub fn finish(self: *const DataOffer, writer: anytype, params: finish_params) !void {
        log.debug("    Sending DataOffer::finish {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_actions_params = struct {
        pub const op = 4;
        /// actions supported by the destination client
        dnd_actions: DataDeviceManager.DndAction,
        /// action preferred by the destination client
        preferred_action: DataDeviceManager.DndAction,
    };

    /// set the available/preferred drag-and-drop actions
    pub fn set_actions(self: *const DataOffer, writer: anytype, params: set_actions_params) !void {
        log.debug("    Sending DataOffer::set_actions {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        offer: Event.Offer,
        source_actions: Event.SourceActions,
        action: Event.Action,

        /// advertise offered mime type
        pub const Offer = struct {
            mime_type: [:0]const u8,
        };

        /// notify the source-side available actions
        pub const SourceActions = struct {
            source_actions: DataDeviceManager.DndAction,
        };

        /// notify the selected action
        pub const Action = struct {
            dnd_action: DataDeviceManager.DndAction,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .offer = try wl_msg.parse_data(sock, Event.Offer, data) },
                1 => .{ .source_actions = try wl_msg.parse_data(sock, Event.SourceActions, data) },
                2 => .{ .action = try wl_msg.parse_data(sock, Event.Action, data) },
                else => {
                    log.warn("Unknown data_offer event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// offer to transfer data
pub const DataSource = struct {
    id: u32,
    version: u32 = 3,
    pub const Error = enum(u32) {
        /// action mask contains invalid values
        invalid_action_mask = 0,
        /// source doesn't accept this request
        invalid_source = 1,
    };
    pub const offer_params = struct {
        pub const op = 0;
        /// mime type offered by the data source
        mime_type: [:0]const u8,
    };

    /// add an offered mime type
    pub fn offer(self: *const DataSource, writer: anytype, params: offer_params) !void {
        log.debug("    Sending DataSource::offer {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const destroy_params = struct {
        pub const op = 1;
    };

    /// destroy the data source
    pub fn destroy(self: *const DataSource, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending DataSource::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_actions_params = struct {
        pub const op = 2;
        /// actions supported by the data source
        dnd_actions: DataDeviceManager.DndAction,
    };

    /// set the available drag-and-drop actions
    pub fn set_actions(self: *const DataSource, writer: anytype, params: set_actions_params) !void {
        log.debug("    Sending DataSource::set_actions {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        target: Event.Target,
        send: Event.Send,
        cancelled: Event.Cancelled,
        dnd_drop_performed: Event.DndDropPerformed,
        dnd_finished: Event.DndFinished,
        action: Event.Action,

        /// a target accepts an offered mime type
        pub const Target = struct {
            mime_type: [:0]const u8,
        };

        /// send the data
        pub const Send = struct {
            mime_type: [:0]const u8,
            fd: wl_msg.FileDescriptor,
        };

        /// selection was cancelled
        pub const Cancelled = struct {};

        /// the drag-and-drop operation physically finished
        pub const DndDropPerformed = struct {};

        /// the drag-and-drop operation concluded
        pub const DndFinished = struct {};

        /// notify the selected action
        pub const Action = struct {
            dnd_action: DataDeviceManager.DndAction,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .target = try wl_msg.parse_data(sock, Event.Target, data) },
                1 => .{ .send = try wl_msg.parse_data(sock, Event.Send, data) },
                2 => .{ .cancelled = try wl_msg.parse_data(sock, Event.Cancelled, data) },
                3 => .{ .dnd_drop_performed = try wl_msg.parse_data(sock, Event.DndDropPerformed, data) },
                4 => .{ .dnd_finished = try wl_msg.parse_data(sock, Event.DndFinished, data) },
                5 => .{ .action = try wl_msg.parse_data(sock, Event.Action, data) },
                else => {
                    log.warn("Unknown data_source event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// data transfer device
pub const DataDevice = struct {
    id: u32,
    version: u32 = 3,
    pub const Error = enum(u32) {
        /// given wl_surface has another role
        role = 0,
        /// source has already been used
        used_source = 1,
    };
    pub const start_drag_params = struct {
        pub const op = 0;
        /// data source for the eventual transfer
        source: u32,
        /// surface where the drag originates
        origin: u32,
        /// drag-and-drop icon surface
        icon: u32,
        /// serial number of the implicit grab on the origin
        serial: u32,
    };

    /// start drag-and-drop operation
    pub fn start_drag(self: *const DataDevice, writer: anytype, params: start_drag_params) !void {
        log.debug("    Sending DataDevice::start_drag {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_selection_params = struct {
        pub const op = 1;
        /// data source for the selection
        source: u32,
        /// serial number of the event that triggered this request
        serial: u32,
    };

    /// copy data to the selection
    pub fn set_selection(self: *const DataDevice, writer: anytype, params: set_selection_params) !void {
        log.debug("    Sending DataDevice::set_selection {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const release_params = struct {
        pub const op = 2;
    };

    /// destroy data device
    pub fn release(self: *const DataDevice, writer: anytype, params: release_params) !void {
        log.debug("    Sending DataDevice::release {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        data_offer: Event.DataOffer,
        enter: Event.Enter,
        leave: Event.Leave,
        motion: Event.Motion,
        drop: Event.Drop,
        selection: Event.Selection,

        /// introduce a new wl_data_offer
        pub const DataOffer = struct {
            id: u32,
        };

        /// initiate drag-and-drop session
        pub const Enter = struct {
            serial: u32,
            surface: u32,
            x: f32,
            y: f32,
            id: u32,
        };

        /// end drag-and-drop session
        pub const Leave = struct {};

        /// drag-and-drop session motion
        pub const Motion = struct {
            time: u32,
            x: f32,
            y: f32,
        };

        /// end drag-and-drop session successfully
        pub const Drop = struct {};

        /// advertise new selection
        pub const Selection = struct {
            id: u32,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .data_offer = try wl_msg.parse_data(sock, Event.DataOffer, data) },
                1 => .{ .enter = try wl_msg.parse_data(sock, Event.Enter, data) },
                2 => .{ .leave = try wl_msg.parse_data(sock, Event.Leave, data) },
                3 => .{ .motion = try wl_msg.parse_data(sock, Event.Motion, data) },
                4 => .{ .drop = try wl_msg.parse_data(sock, Event.Drop, data) },
                5 => .{ .selection = try wl_msg.parse_data(sock, Event.Selection, data) },
                else => {
                    log.warn("Unknown data_device event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// data transfer interface
pub const DataDeviceManager = struct {
    id: u32,
    version: u32 = 3,

    /// drag and drop actions
    pub const DndAction = packed struct(u32) {
        /// no action
        none: bool = false,
        /// copy action
        copy: bool = false,
        /// move action
        move: bool = false,
        /// ask action
        ask: bool = false,
        __reserved_bit_4: bool = false,
        __reserved_bit_5: bool = false,
        __reserved_bit_6: bool = false,
        __reserved_bit_7: bool = false,
        __reserved_bit_8: bool = false,
        __reserved_bit_9: bool = false,
        __reserved_bit_10: bool = false,
        __reserved_bit_11: bool = false,
        __reserved_bit_12: bool = false,
        __reserved_bit_13: bool = false,
        __reserved_bit_14: bool = false,
        __reserved_bit_15: bool = false,
        __reserved_bit_16: bool = false,
        __reserved_bit_17: bool = false,
        __reserved_bit_18: bool = false,
        __reserved_bit_19: bool = false,
        __reserved_bit_20: bool = false,
        __reserved_bit_21: bool = false,
        __reserved_bit_22: bool = false,
        __reserved_bit_23: bool = false,
        __reserved_bit_24: bool = false,
        __reserved_bit_25: bool = false,
        __reserved_bit_26: bool = false,
        __reserved_bit_27: bool = false,
        __reserved_bit_28: bool = false,
        __reserved_bit_29: bool = false,
        __reserved_bit_30: bool = false,
        __reserved_bit_31: bool = false,
    };
    pub const create_data_source_params = struct {
        pub const op = 0;
        /// data source to create
        id: u32,
    };

    /// create a new data source
    pub fn create_data_source(self: *const DataDeviceManager, writer: anytype, params: create_data_source_params) !void {
        log.debug("    Sending DataDeviceManager::create_data_source {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const get_data_device_params = struct {
        pub const op = 1;
        /// data device to create
        id: u32,
        /// seat associated with the data device
        seat: u32,
    };

    /// create a new data device
    pub fn get_data_device(self: *const DataDeviceManager, writer: anytype, params: get_data_device_params) !void {
        log.debug("    Sending DataDeviceManager::get_data_device {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
};

/// create desktop-style surfaces
pub const Shell = struct {
    id: u32,
    version: u32 = 1,
    pub const Error = enum(u32) {
        /// given wl_surface has another role
        role = 0,
    };
    pub const get_shell_surface_params = struct {
        pub const op = 0;
        /// shell surface to create
        id: u32,
        /// surface to be given the shell surface role
        surface: u32,
    };

    /// create a shell surface from a surface
    pub fn get_shell_surface(self: *const Shell, writer: anytype, params: get_shell_surface_params) !void {
        log.debug("    Sending Shell::get_shell_surface {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
};

/// desktop-style metadata interface
pub const ShellSurface = struct {
    id: u32,
    version: u32 = 1,

    /// edge values for resizing
    pub const Resize = packed struct(u32) {
        /// no edge
        none: bool = false,
        /// top edge
        top: bool = false,
        /// bottom edge
        bottom: bool = false,
        /// left edge
        left: bool = false,
        /// top and left edges
        top_left: bool = false,
        /// bottom and left edges
        bottom_left: bool = false,
        /// right edge
        right: bool = false,
        /// top and right edges
        top_right: bool = false,
        /// bottom and right edges
        bottom_right: bool = false,
        __reserved_bit_9: bool = false,
        __reserved_bit_10: bool = false,
        __reserved_bit_11: bool = false,
        __reserved_bit_12: bool = false,
        __reserved_bit_13: bool = false,
        __reserved_bit_14: bool = false,
        __reserved_bit_15: bool = false,
        __reserved_bit_16: bool = false,
        __reserved_bit_17: bool = false,
        __reserved_bit_18: bool = false,
        __reserved_bit_19: bool = false,
        __reserved_bit_20: bool = false,
        __reserved_bit_21: bool = false,
        __reserved_bit_22: bool = false,
        __reserved_bit_23: bool = false,
        __reserved_bit_24: bool = false,
        __reserved_bit_25: bool = false,
        __reserved_bit_26: bool = false,
        __reserved_bit_27: bool = false,
        __reserved_bit_28: bool = false,
        __reserved_bit_29: bool = false,
        __reserved_bit_30: bool = false,
        __reserved_bit_31: bool = false,
    };
    /// details of transient behaviour
    pub const Transient = packed struct(u32) {
        /// do not set keyboard focus
        inactive: bool = false,
        __reserved_bit_1: bool = false,
        __reserved_bit_2: bool = false,
        __reserved_bit_3: bool = false,
        __reserved_bit_4: bool = false,
        __reserved_bit_5: bool = false,
        __reserved_bit_6: bool = false,
        __reserved_bit_7: bool = false,
        __reserved_bit_8: bool = false,
        __reserved_bit_9: bool = false,
        __reserved_bit_10: bool = false,
        __reserved_bit_11: bool = false,
        __reserved_bit_12: bool = false,
        __reserved_bit_13: bool = false,
        __reserved_bit_14: bool = false,
        __reserved_bit_15: bool = false,
        __reserved_bit_16: bool = false,
        __reserved_bit_17: bool = false,
        __reserved_bit_18: bool = false,
        __reserved_bit_19: bool = false,
        __reserved_bit_20: bool = false,
        __reserved_bit_21: bool = false,
        __reserved_bit_22: bool = false,
        __reserved_bit_23: bool = false,
        __reserved_bit_24: bool = false,
        __reserved_bit_25: bool = false,
        __reserved_bit_26: bool = false,
        __reserved_bit_27: bool = false,
        __reserved_bit_28: bool = false,
        __reserved_bit_29: bool = false,
        __reserved_bit_30: bool = false,
        __reserved_bit_31: bool = false,
    };
    /// different method to set the surface fullscreen
    pub const FullscreenMethod = enum(u32) {
        /// no preference, apply default policy
        default = 0,
        /// scale, preserve the surface's aspect ratio and center on output
        scale = 1,
        /// switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
        driver = 2,
        /// no upscaling, center on output and add black borders to compensate size mismatch
        fill = 3,
    };
    pub const pong_params = struct {
        pub const op = 0;
        /// serial number of the ping event
        serial: u32,
    };

    /// respond to a ping event
    pub fn pong(self: *const ShellSurface, writer: anytype, params: pong_params) !void {
        log.debug("    Sending ShellSurface::pong {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const move_params = struct {
        pub const op = 1;
        /// seat whose pointer is used
        seat: u32,
        /// serial number of the implicit grab on the pointer
        serial: u32,
    };

    /// start an interactive move
    pub fn move(self: *const ShellSurface, writer: anytype, params: move_params) !void {
        log.debug("    Sending ShellSurface::move {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const resize_params = struct {
        pub const op = 2;
        /// seat whose pointer is used
        seat: u32,
        /// serial number of the implicit grab on the pointer
        serial: u32,
        /// which edge or corner is being dragged
        edges: Resize,
    };

    /// start an interactive resize
    pub fn resize(self: *const ShellSurface, writer: anytype, params: resize_params) !void {
        log.debug("    Sending ShellSurface::resize {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_toplevel_params = struct {
        pub const op = 3;
    };

    /// make the surface a toplevel surface
    pub fn set_toplevel(self: *const ShellSurface, writer: anytype, params: set_toplevel_params) !void {
        log.debug("    Sending ShellSurface::set_toplevel {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_transient_params = struct {
        pub const op = 4;
        /// parent surface
        parent: u32,
        /// surface-local x coordinate
        x: i32,
        /// surface-local y coordinate
        y: i32,
        /// transient surface behavior
        flags: Transient,
    };

    /// make the surface a transient surface
    pub fn set_transient(self: *const ShellSurface, writer: anytype, params: set_transient_params) !void {
        log.debug("    Sending ShellSurface::set_transient {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_fullscreen_params = struct {
        pub const op = 5;
        /// method for resolving size conflict
        method: FullscreenMethod,
        /// framerate in mHz
        framerate: u32,
        /// output on which the surface is to be fullscreen
        output: u32,
    };

    /// make the surface a fullscreen surface
    pub fn set_fullscreen(self: *const ShellSurface, writer: anytype, params: set_fullscreen_params) !void {
        log.debug("    Sending ShellSurface::set_fullscreen {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_popup_params = struct {
        pub const op = 6;
        /// seat whose pointer is used
        seat: u32,
        /// serial number of the implicit grab on the pointer
        serial: u32,
        /// parent surface
        parent: u32,
        /// surface-local x coordinate
        x: i32,
        /// surface-local y coordinate
        y: i32,
        /// transient surface behavior
        flags: Transient,
    };

    /// make the surface a popup surface
    pub fn set_popup(self: *const ShellSurface, writer: anytype, params: set_popup_params) !void {
        log.debug("    Sending ShellSurface::set_popup {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_maximized_params = struct {
        pub const op = 7;
        /// output on which the surface is to be maximized
        output: u32,
    };

    /// make the surface a maximized surface
    pub fn set_maximized(self: *const ShellSurface, writer: anytype, params: set_maximized_params) !void {
        log.debug("    Sending ShellSurface::set_maximized {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_title_params = struct {
        pub const op = 8;
        /// surface title
        title: [:0]const u8,
    };

    /// set surface title
    pub fn set_title(self: *const ShellSurface, writer: anytype, params: set_title_params) !void {
        log.debug("    Sending ShellSurface::set_title {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_class_params = struct {
        pub const op = 9;
        /// surface class
        class_: [:0]const u8,
    };

    /// set surface class
    pub fn set_class(self: *const ShellSurface, writer: anytype, params: set_class_params) !void {
        log.debug("    Sending ShellSurface::set_class {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        ping: Event.Ping,
        configure: Event.Configure,
        popup_done: Event.PopupDone,

        /// ping client
        pub const Ping = struct {
            serial: u32,
        };

        /// suggest resize
        pub const Configure = struct {
            edges: ShellSurface.Resize,
            width: i32,
            height: i32,
        };

        /// popup interaction is done
        pub const PopupDone = struct {};
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .ping = try wl_msg.parse_data(sock, Event.Ping, data) },
                1 => .{ .configure = try wl_msg.parse_data(sock, Event.Configure, data) },
                2 => .{ .popup_done = try wl_msg.parse_data(sock, Event.PopupDone, data) },
                else => {
                    log.warn("Unknown shell_surface event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// an onscreen surface
pub const Surface = struct {
    id: u32,
    version: u32 = 6,

    /// wl_surface error values
    pub const Error = enum(u32) {
        /// buffer scale value is invalid
        invalid_scale = 0,
        /// buffer transform value is invalid
        invalid_transform = 1,
        /// buffer size is invalid
        invalid_size = 2,
        /// buffer offset is invalid
        invalid_offset = 3,
        /// surface was destroyed before its role object
        defunct_role_object = 4,
    };
    pub const destroy_params = struct {
        pub const op = 0;
    };

    /// delete surface
    pub fn destroy(self: *const Surface, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending Surface::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const attach_params = struct {
        pub const op = 1;
        /// buffer of surface contents
        buffer: u32,
        /// surface-local x coordinate
        x: i32,
        /// surface-local y coordinate
        y: i32,
    };

    /// set the surface contents
    pub fn attach(self: *const Surface, writer: anytype, params: attach_params) !void {
        log.debug("    Sending Surface::attach {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const damage_params = struct {
        pub const op = 2;
        /// surface-local x coordinate
        x: i32,
        /// surface-local y coordinate
        y: i32,
        /// width of damage rectangle
        width: i32,
        /// height of damage rectangle
        height: i32,
    };

    /// mark part of the surface damaged
    pub fn damage(self: *const Surface, writer: anytype, params: damage_params) !void {
        log.debug("    Sending Surface::damage {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const frame_params = struct {
        pub const op = 3;
        /// callback object for the frame request
        callback: u32,
    };

    /// request a frame throttling hint
    pub fn frame(self: *const Surface, writer: anytype, params: frame_params) !void {
        log.debug("    Sending Surface::frame {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_opaque_region_params = struct {
        pub const op = 4;
        /// opaque region of the surface
        region: u32,
    };

    /// set opaque region
    pub fn set_opaque_region(self: *const Surface, writer: anytype, params: set_opaque_region_params) !void {
        log.debug("    Sending Surface::set_opaque_region {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_input_region_params = struct {
        pub const op = 5;
        /// input region of the surface
        region: u32,
    };

    /// set input region
    pub fn set_input_region(self: *const Surface, writer: anytype, params: set_input_region_params) !void {
        log.debug("    Sending Surface::set_input_region {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const commit_params = struct {
        pub const op = 6;
    };

    /// commit pending surface state
    pub fn commit(self: *const Surface, writer: anytype, params: commit_params) !void {
        log.debug("    Sending Surface::commit {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_buffer_transform_params = struct {
        pub const op = 7;
        /// transform for interpreting buffer contents
        transform: Output.Transform,
    };

    /// sets the buffer transformation
    pub fn set_buffer_transform(self: *const Surface, writer: anytype, params: set_buffer_transform_params) !void {
        log.debug("    Sending Surface::set_buffer_transform {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_buffer_scale_params = struct {
        pub const op = 8;
        /// scale for interpreting buffer contents
        scale: i32,
    };

    /// sets the buffer scaling factor
    pub fn set_buffer_scale(self: *const Surface, writer: anytype, params: set_buffer_scale_params) !void {
        log.debug("    Sending Surface::set_buffer_scale {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const damage_buffer_params = struct {
        pub const op = 9;
        /// buffer-local x coordinate
        x: i32,
        /// buffer-local y coordinate
        y: i32,
        /// width of damage rectangle
        width: i32,
        /// height of damage rectangle
        height: i32,
    };

    /// mark part of the surface damaged using buffer coordinates
    pub fn damage_buffer(self: *const Surface, writer: anytype, params: damage_buffer_params) !void {
        log.debug("    Sending Surface::damage_buffer {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const offset_params = struct {
        pub const op = 10;
        /// surface-local x coordinate
        x: i32,
        /// surface-local y coordinate
        y: i32,
    };

    /// set the surface contents offset
    pub fn offset(self: *const Surface, writer: anytype, params: offset_params) !void {
        log.debug("    Sending Surface::offset {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        enter: Event.Enter,
        leave: Event.Leave,
        preferred_buffer_scale: Event.PreferredBufferScale,
        preferred_buffer_transform: Event.PreferredBufferTransform,

        /// surface enters an output
        pub const Enter = struct {
            output: u32,
        };

        /// surface leaves an output
        pub const Leave = struct {
            output: u32,
        };

        /// preferred buffer scale for the surface
        pub const PreferredBufferScale = struct {
            factor: i32,
        };

        /// preferred buffer transform for the surface
        pub const PreferredBufferTransform = struct {
            transform: Output.Transform,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .enter = try wl_msg.parse_data(sock, Event.Enter, data) },
                1 => .{ .leave = try wl_msg.parse_data(sock, Event.Leave, data) },
                2 => .{ .preferred_buffer_scale = try wl_msg.parse_data(sock, Event.PreferredBufferScale, data) },
                3 => .{ .preferred_buffer_transform = try wl_msg.parse_data(sock, Event.PreferredBufferTransform, data) },
                else => {
                    log.warn("Unknown surface event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// group of input devices
pub const Seat = struct {
    id: u32,
    version: u32 = 10,

    /// seat capability bitmask
    pub const Capability = packed struct(u32) {
        /// the seat has pointer devices
        pointer: bool = false,
        /// the seat has one or more keyboards
        keyboard: bool = false,
        /// the seat has touch devices
        touch: bool = false,
        __reserved_bit_3: bool = false,
        __reserved_bit_4: bool = false,
        __reserved_bit_5: bool = false,
        __reserved_bit_6: bool = false,
        __reserved_bit_7: bool = false,
        __reserved_bit_8: bool = false,
        __reserved_bit_9: bool = false,
        __reserved_bit_10: bool = false,
        __reserved_bit_11: bool = false,
        __reserved_bit_12: bool = false,
        __reserved_bit_13: bool = false,
        __reserved_bit_14: bool = false,
        __reserved_bit_15: bool = false,
        __reserved_bit_16: bool = false,
        __reserved_bit_17: bool = false,
        __reserved_bit_18: bool = false,
        __reserved_bit_19: bool = false,
        __reserved_bit_20: bool = false,
        __reserved_bit_21: bool = false,
        __reserved_bit_22: bool = false,
        __reserved_bit_23: bool = false,
        __reserved_bit_24: bool = false,
        __reserved_bit_25: bool = false,
        __reserved_bit_26: bool = false,
        __reserved_bit_27: bool = false,
        __reserved_bit_28: bool = false,
        __reserved_bit_29: bool = false,
        __reserved_bit_30: bool = false,
        __reserved_bit_31: bool = false,
    };
    /// wl_seat error values
    pub const Error = enum(u32) {
        /// get_pointer, get_keyboard or get_touch called on seat without the matching capability
        missing_capability = 0,
    };
    pub const get_pointer_params = struct {
        pub const op = 0;
        /// seat pointer
        id: u32,
    };

    /// return pointer object
    pub fn get_pointer(self: *const Seat, writer: anytype, params: get_pointer_params) !void {
        log.debug("    Sending Seat::get_pointer {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const get_keyboard_params = struct {
        pub const op = 1;
        /// seat keyboard
        id: u32,
    };

    /// return keyboard object
    pub fn get_keyboard(self: *const Seat, writer: anytype, params: get_keyboard_params) !void {
        log.debug("    Sending Seat::get_keyboard {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const get_touch_params = struct {
        pub const op = 2;
        /// seat touch interface
        id: u32,
    };

    /// return touch object
    pub fn get_touch(self: *const Seat, writer: anytype, params: get_touch_params) !void {
        log.debug("    Sending Seat::get_touch {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const release_params = struct {
        pub const op = 3;
    };

    /// release the seat object
    pub fn release(self: *const Seat, writer: anytype, params: release_params) !void {
        log.debug("    Sending Seat::release {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        capabilities: Event.Capabilities,
        name: Event.Name,

        /// seat capabilities changed
        pub const Capabilities = struct {
            capabilities: Seat.Capability,
        };

        /// unique identifier for this seat
        pub const Name = struct {
            name: [:0]const u8,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .capabilities = try wl_msg.parse_data(sock, Event.Capabilities, data) },
                1 => .{ .name = try wl_msg.parse_data(sock, Event.Name, data) },
                else => {
                    log.warn("Unknown seat event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// pointer input device
pub const Pointer = struct {
    id: u32,
    version: u32 = 10,
    pub const Error = enum(u32) {
        /// given wl_surface has another role
        role = 0,
    };
    /// physical button state
    pub const ButtonState = enum(u32) {
        /// the button is not pressed
        released = 0,
        /// the button is pressed
        pressed = 1,
    };
    /// axis types
    pub const Axis = enum(u32) {
        /// vertical axis
        vertical_scroll = 0,
        /// horizontal axis
        horizontal_scroll = 1,
    };
    /// axis source types
    pub const AxisSource = enum(u32) {
        /// a physical wheel rotation
        wheel = 0,
        /// finger on a touch surface
        finger = 1,
        /// continuous coordinate space
        continuous = 2,
        /// a physical wheel tilt
        wheel_tilt = 3,
    };
    /// axis relative direction
    pub const AxisRelativeDirection = enum(u32) {
        /// physical motion matches axis direction
        identical = 0,
        /// physical motion is the inverse of the axis direction
        inverted = 1,
    };
    pub const set_cursor_params = struct {
        pub const op = 0;
        /// serial number of the enter event
        serial: u32,
        /// pointer surface
        surface: u32,
        /// surface-local x coordinate
        hotspot_x: i32,
        /// surface-local y coordinate
        hotspot_y: i32,
    };

    /// set the pointer surface
    pub fn set_cursor(self: *const Pointer, writer: anytype, params: set_cursor_params) !void {
        log.debug("    Sending Pointer::set_cursor {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const release_params = struct {
        pub const op = 1;
    };

    /// release the pointer object
    pub fn release(self: *const Pointer, writer: anytype, params: release_params) !void {
        log.debug("    Sending Pointer::release {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        enter: Event.Enter,
        leave: Event.Leave,
        motion: Event.Motion,
        button: Event.Button,
        axis: Event.Axis,
        frame: Event.Frame,
        axis_source: Event.AxisSource,
        axis_stop: Event.AxisStop,
        axis_discrete: Event.AxisDiscrete,
        axis_value120: Event.AxisValue120,
        axis_relative_direction: Event.AxisRelativeDirection,

        /// enter event
        pub const Enter = struct {
            serial: u32,
            surface: u32,
            surface_x: f32,
            surface_y: f32,
        };

        /// leave event
        pub const Leave = struct {
            serial: u32,
            surface: u32,
        };

        /// pointer motion event
        pub const Motion = struct {
            time: u32,
            surface_x: f32,
            surface_y: f32,
        };

        /// pointer button event
        pub const Button = struct {
            serial: u32,
            time: u32,
            button: u32,
            state: Pointer.ButtonState,
        };

        /// axis event
        pub const Axis = struct {
            time: u32,
            axis: Pointer.Axis,
            value: f32,
        };

        /// end of a pointer event sequence
        pub const Frame = struct {};

        /// axis source event
        pub const AxisSource = struct {
            axis_source: Pointer.AxisSource,
        };

        /// axis stop event
        pub const AxisStop = struct {
            time: u32,
            axis: Pointer.Axis,
        };

        /// axis click event
        pub const AxisDiscrete = struct {
            axis: Pointer.Axis,
            discrete: i32,
        };

        /// axis high-resolution scroll event
        pub const AxisValue120 = struct {
            axis: Pointer.Axis,
            value120: i32,
        };

        /// axis relative physical direction event
        pub const AxisRelativeDirection = struct {
            axis: Pointer.Axis,
            direction: Pointer.AxisRelativeDirection,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .enter = try wl_msg.parse_data(sock, Event.Enter, data) },
                1 => .{ .leave = try wl_msg.parse_data(sock, Event.Leave, data) },
                2 => .{ .motion = try wl_msg.parse_data(sock, Event.Motion, data) },
                3 => .{ .button = try wl_msg.parse_data(sock, Event.Button, data) },
                4 => .{ .axis = try wl_msg.parse_data(sock, Event.Axis, data) },
                5 => .{ .frame = try wl_msg.parse_data(sock, Event.Frame, data) },
                6 => .{ .axis_source = try wl_msg.parse_data(sock, Event.AxisSource, data) },
                7 => .{ .axis_stop = try wl_msg.parse_data(sock, Event.AxisStop, data) },
                8 => .{ .axis_discrete = try wl_msg.parse_data(sock, Event.AxisDiscrete, data) },
                9 => .{ .axis_value120 = try wl_msg.parse_data(sock, Event.AxisValue120, data) },
                10 => .{ .axis_relative_direction = try wl_msg.parse_data(sock, Event.AxisRelativeDirection, data) },
                else => {
                    log.warn("Unknown pointer event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// keyboard input device
pub const Keyboard = struct {
    id: u32,
    version: u32 = 10,

    /// keyboard mapping format
    pub const KeymapFormat = enum(u32) {
        /// no keymap; client must understand how to interpret the raw keycode
        no_keymap = 0,
        /// libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
        xkb_v1 = 1,
    };
    /// physical key state
    pub const KeyState = enum(u32) {
        /// key is not pressed
        released = 0,
        /// key is pressed
        pressed = 1,
        /// key was repeated
        repeated = 2,
    };
    pub const release_params = struct {
        pub const op = 0;
    };

    /// release the keyboard object
    pub fn release(self: *const Keyboard, writer: anytype, params: release_params) !void {
        log.debug("    Sending Keyboard::release {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        keymap: Event.Keymap,
        enter: Event.Enter,
        leave: Event.Leave,
        key: Event.Key,
        modifiers: Event.Modifiers,
        repeat_info: Event.RepeatInfo,

        /// keyboard mapping
        pub const Keymap = struct {
            format: Keyboard.KeymapFormat,
            fd: wl_msg.FileDescriptor,
            size: u32,
        };

        /// enter event
        pub const Enter = struct {
            serial: u32,
            surface: u32,
            keys: []const u8,
        };

        /// leave event
        pub const Leave = struct {
            serial: u32,
            surface: u32,
        };

        /// key event
        pub const Key = struct {
            serial: u32,
            time: u32,
            key: u32,
            state: Keyboard.KeyState,
        };

        /// modifier and group state
        pub const Modifiers = struct {
            serial: u32,
            mods_depressed: u32,
            mods_latched: u32,
            mods_locked: u32,
            group: u32,
        };

        /// repeat rate and delay
        pub const RepeatInfo = struct {
            rate: i32,
            delay: i32,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .keymap = try wl_msg.parse_data(sock, Event.Keymap, data) },
                1 => .{ .enter = try wl_msg.parse_data(sock, Event.Enter, data) },
                2 => .{ .leave = try wl_msg.parse_data(sock, Event.Leave, data) },
                3 => .{ .key = try wl_msg.parse_data(sock, Event.Key, data) },
                4 => .{ .modifiers = try wl_msg.parse_data(sock, Event.Modifiers, data) },
                5 => .{ .repeat_info = try wl_msg.parse_data(sock, Event.RepeatInfo, data) },
                else => {
                    log.warn("Unknown keyboard event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// touchscreen input device
pub const Touch = struct {
    id: u32,
    version: u32 = 10,

    pub const release_params = struct {
        pub const op = 0;
    };

    /// release the touch object
    pub fn release(self: *const Touch, writer: anytype, params: release_params) !void {
        log.debug("    Sending Touch::release {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        down: Event.Down,
        up: Event.Up,
        motion: Event.Motion,
        frame: Event.Frame,
        cancel: Event.Cancel,
        shape: Event.Shape,
        orientation: Event.Orientation,

        /// touch down event and beginning of a touch sequence
        pub const Down = struct {
            serial: u32,
            time: u32,
            surface: u32,
            id: i32,
            x: f32,
            y: f32,
        };

        /// end of a touch event sequence
        pub const Up = struct {
            serial: u32,
            time: u32,
            id: i32,
        };

        /// update of touch point coordinates
        pub const Motion = struct {
            time: u32,
            id: i32,
            x: f32,
            y: f32,
        };

        /// end of touch frame event
        pub const Frame = struct {};

        /// touch session cancelled
        pub const Cancel = struct {};

        /// update shape of touch point
        pub const Shape = struct {
            id: i32,
            major: f32,
            minor: f32,
        };

        /// update orientation of touch point
        pub const Orientation = struct {
            id: i32,
            orientation: f32,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .down = try wl_msg.parse_data(sock, Event.Down, data) },
                1 => .{ .up = try wl_msg.parse_data(sock, Event.Up, data) },
                2 => .{ .motion = try wl_msg.parse_data(sock, Event.Motion, data) },
                3 => .{ .frame = try wl_msg.parse_data(sock, Event.Frame, data) },
                4 => .{ .cancel = try wl_msg.parse_data(sock, Event.Cancel, data) },
                5 => .{ .shape = try wl_msg.parse_data(sock, Event.Shape, data) },
                6 => .{ .orientation = try wl_msg.parse_data(sock, Event.Orientation, data) },
                else => {
                    log.warn("Unknown touch event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// compositor output region
pub const Output = struct {
    id: u32,
    version: u32 = 4,

    /// subpixel geometry information
    pub const Subpixel = enum(u32) {
        /// unknown geometry
        unknown = 0,
        /// no geometry
        none = 1,
        /// horizontal RGB
        horizontal_rgb = 2,
        /// horizontal BGR
        horizontal_bgr = 3,
        /// vertical RGB
        vertical_rgb = 4,
        /// vertical BGR
        vertical_bgr = 5,
    };
    /// transformation applied to buffer contents
    pub const Transform = enum(u32) {
        /// no transform
        normal = 0,
        /// 90 degrees counter-clockwise
        @"90" = 1,
        /// 180 degrees counter-clockwise
        @"180" = 2,
        /// 270 degrees counter-clockwise
        @"270" = 3,
        /// 180 degree flip around a vertical axis
        flipped = 4,
        /// flip and rotate 90 degrees counter-clockwise
        flipped_90 = 5,
        /// flip and rotate 180 degrees counter-clockwise
        flipped_180 = 6,
        /// flip and rotate 270 degrees counter-clockwise
        flipped_270 = 7,
    };
    /// mode information
    pub const Mode = packed struct(u32) {
        /// indicates this is the current mode
        current: bool = false,
        /// indicates this is the preferred mode
        preferred: bool = false,
        __reserved_bit_2: bool = false,
        __reserved_bit_3: bool = false,
        __reserved_bit_4: bool = false,
        __reserved_bit_5: bool = false,
        __reserved_bit_6: bool = false,
        __reserved_bit_7: bool = false,
        __reserved_bit_8: bool = false,
        __reserved_bit_9: bool = false,
        __reserved_bit_10: bool = false,
        __reserved_bit_11: bool = false,
        __reserved_bit_12: bool = false,
        __reserved_bit_13: bool = false,
        __reserved_bit_14: bool = false,
        __reserved_bit_15: bool = false,
        __reserved_bit_16: bool = false,
        __reserved_bit_17: bool = false,
        __reserved_bit_18: bool = false,
        __reserved_bit_19: bool = false,
        __reserved_bit_20: bool = false,
        __reserved_bit_21: bool = false,
        __reserved_bit_22: bool = false,
        __reserved_bit_23: bool = false,
        __reserved_bit_24: bool = false,
        __reserved_bit_25: bool = false,
        __reserved_bit_26: bool = false,
        __reserved_bit_27: bool = false,
        __reserved_bit_28: bool = false,
        __reserved_bit_29: bool = false,
        __reserved_bit_30: bool = false,
        __reserved_bit_31: bool = false,
    };
    pub const release_params = struct {
        pub const op = 0;
    };

    /// release the output object
    pub fn release(self: *const Output, writer: anytype, params: release_params) !void {
        log.debug("    Sending Output::release {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
    pub const Event = union(enum) {
        geometry: Event.Geometry,
        mode: Event.Mode,
        done: Event.Done,
        scale: Event.Scale,
        name: Event.Name,
        description: Event.Description,

        /// properties of the output
        pub const Geometry = struct {
            x: i32,
            y: i32,
            physical_width: i32,
            physical_height: i32,
            subpixel: Output.Subpixel,
            make: [:0]const u8,
            model: [:0]const u8,
            transform: Output.Transform,
        };

        /// advertise available modes for the output
        pub const Mode = struct {
            flags: Output.Mode,
            width: i32,
            height: i32,
            refresh: i32,
        };

        /// sent all information about output
        pub const Done = struct {};

        /// output scaling properties
        pub const Scale = struct {
            factor: i32,
        };

        /// name of this output
        pub const Name = struct {
            name: [:0]const u8,
        };

        /// human-readable description of this output
        pub const Description = struct {
            description: [:0]const u8,
        };
        pub fn parse(sock: std.posix.socket_t, op: u32, data: []const u8) !Event {
            return switch (op) {
                0 => .{ .geometry = try wl_msg.parse_data(sock, Event.Geometry, data) },
                1 => .{ .mode = try wl_msg.parse_data(sock, Event.Mode, data) },
                2 => .{ .done = try wl_msg.parse_data(sock, Event.Done, data) },
                3 => .{ .scale = try wl_msg.parse_data(sock, Event.Scale, data) },
                4 => .{ .name = try wl_msg.parse_data(sock, Event.Name, data) },
                5 => .{ .description = try wl_msg.parse_data(sock, Event.Description, data) },
                else => {
                    log.warn("Unknown output event: {d}", .{op});
                    return error.UnknownEvent;
                },
            };
        }
    };
};

/// region interface
pub const Region = struct {
    id: u32,
    version: u32 = 1,

    pub const destroy_params = struct {
        pub const op = 0;
    };

    /// destroy region
    pub fn destroy(self: *const Region, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending Region::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const add_params = struct {
        pub const op = 1;
        /// region-local x coordinate
        x: i32,
        /// region-local y coordinate
        y: i32,
        /// rectangle width
        width: i32,
        /// rectangle height
        height: i32,
    };

    /// add rectangle to region
    pub fn add(self: *const Region, writer: anytype, params: add_params) !void {
        log.debug("    Sending Region::add {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const subtract_params = struct {
        pub const op = 2;
        /// region-local x coordinate
        x: i32,
        /// region-local y coordinate
        y: i32,
        /// rectangle width
        width: i32,
        /// rectangle height
        height: i32,
    };

    /// subtract rectangle from region
    pub fn subtract(self: *const Region, writer: anytype, params: subtract_params) !void {
        log.debug("    Sending Region::subtract {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
};

/// sub-surface compositing
pub const Subcompositor = struct {
    id: u32,
    version: u32 = 1,
    pub const Error = enum(u32) {
        /// the to-be sub-surface is invalid
        bad_surface = 0,
        /// the to-be sub-surface parent is invalid
        bad_parent = 1,
    };
    pub const destroy_params = struct {
        pub const op = 0;
    };

    /// unbind from the subcompositor interface
    pub fn destroy(self: *const Subcompositor, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending Subcompositor::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const get_subsurface_params = struct {
        pub const op = 1;
        /// the new sub-surface object ID
        id: u32,
        /// the surface to be turned into a sub-surface
        surface: u32,
        /// the parent surface
        parent: u32,
    };

    /// give a surface the role sub-surface
    pub fn get_subsurface(self: *const Subcompositor, writer: anytype, params: get_subsurface_params) !void {
        log.debug("    Sending Subcompositor::get_subsurface {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
};

/// sub-surface interface to a wl_surface
pub const Subsurface = struct {
    id: u32,
    version: u32 = 1,
    pub const Error = enum(u32) {
        /// wl_surface is not a sibling or the parent
        bad_surface = 0,
    };
    pub const destroy_params = struct {
        pub const op = 0;
    };

    /// remove sub-surface interface
    pub fn destroy(self: *const Subsurface, writer: anytype, params: destroy_params) !void {
        log.debug("    Sending Subsurface::destroy {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_position_params = struct {
        pub const op = 1;
        /// x coordinate in the parent surface
        x: i32,
        /// y coordinate in the parent surface
        y: i32,
    };

    /// reposition the sub-surface
    pub fn set_position(self: *const Subsurface, writer: anytype, params: set_position_params) !void {
        log.debug("    Sending Subsurface::set_position {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const place_above_params = struct {
        pub const op = 2;
        /// the reference surface
        sibling: u32,
    };

    /// restack the sub-surface
    pub fn place_above(self: *const Subsurface, writer: anytype, params: place_above_params) !void {
        log.debug("    Sending Subsurface::place_above {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const place_below_params = struct {
        pub const op = 3;
        /// the reference surface
        sibling: u32,
    };

    /// restack the sub-surface
    pub fn place_below(self: *const Subsurface, writer: anytype, params: place_below_params) !void {
        log.debug("    Sending Subsurface::place_below {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_sync_params = struct {
        pub const op = 4;
    };

    /// set sub-surface to synchronized mode
    pub fn set_sync(self: *const Subsurface, writer: anytype, params: set_sync_params) !void {
        log.debug("    Sending Subsurface::set_sync {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }

    pub const set_desync_params = struct {
        pub const op = 5;
    };

    /// set sub-surface to desynchronized mode
    pub fn set_desync(self: *const Subsurface, writer: anytype, params: set_desync_params) !void {
        log.debug("    Sending Subsurface::set_desync {any}", .{params});
        try wl_msg.write(writer, @TypeOf(params), params, self.id);
    }
};
